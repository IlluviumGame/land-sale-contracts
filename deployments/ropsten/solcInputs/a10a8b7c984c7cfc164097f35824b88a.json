{
  "language": "Solidity",
  "sources": {
    "contracts/hardhat-dependency-compiler/@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity >0.0.0;\nimport '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializating the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        assert(_IMPLEMENTATION_SLOT == bytes32(uint256(keccak256(\"eip1967.proxy.implementation\")) - 1));\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overriden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overriden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlot.BooleanSlot storage rollbackTesting = StorageSlot.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            Address.functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/token/ERC721Impl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../interfaces/IdentifiableSpec.sol\";\nimport \"../lib/SafeERC20.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\n/**\n * @title Simplistic ERC721 Implementation\n *\n * @notice Zeppelin based ERC721 implementation, supporting token enumeration\n *      (ERC721Enumerable) and flexible token URI management (Zeppelin ERC721URIStorage)\n *\n * // TODO: consider allowing to override each individual token URI\n *\n * @dev Based on Zeppelin ERC721Enumerable and ERC721URIStorage with some modifications\n *      to tokenURI function\n *\n * @author Basil Gorin\n */\nabstract contract ERC721Impl is IdentifiableToken, MintableERC721, BurnableERC721, ERC721Enumerable, ERC721URIStorage, AccessControl {\n\t// using ERC20.transfer wrapper from OpenZeppelin adopted SafeERC20\n\tusing SafeERC20 for ERC20;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public baseURI = \"\";\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @notice People do mistakes and may send ERC20 tokens by mistake; since\n\t *      NFT smart contract is not designed to accept and hold any ERC20 tokens,\n\t *      it allows the rescue manager to \"rescue\" such lost tokens\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20 tokens accidentally\n\t *      sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing any ERC20 tokens stored\n\t *      on the smart contract balance\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0008_0000;\n\n\t/**\n\t * @dev Fired in _mint() and all the dependent functions like mint(), safeMint()\n\t *\n\t * @param _by an address which executed update\n\t * @param _to an address token was minted to\n\t * @param _tokenId token ID minted\n\t */\n\tevent Minted(address indexed _by, address indexed _to, uint256 indexed _tokenId);\n\n\t/**\n\t * @dev Fired in _burn() and all the dependent functions like burn()\n\t *\n\t * @param _by an address which executed update\n\t * @param _from an address token was burnt from\n\t * @param _tokenId token ID burnt\n\t */\n\tevent Burnt(address indexed _by, address indexed _from, uint256 indexed _tokenId);\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param oldVal old _baseURI value\n\t * @param newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string oldVal, string newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param tokenId token ID which URI was updated\n\t * @param oldVal old _baseURI value\n\t * @param newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 tokenId, string oldVal, string newVal);\n\n\t/**\n\t * @dev Creates/deploys an ERC721 token\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) ERC721(_name, _symbol) AccessControl(msg.sender) {}\n\n\t/**\n\t * @inheritdoc IERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, ERC721Enumerable) returns (bool) {\n\t\t// calculate based on own and inherited interfaces\n\t\treturn ERC721Enumerable.supportsInterface(interfaceId)\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param __baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory __baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, __baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = __baseURI;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _baseURI() internal view virtual override returns (string memory) {\n\t\t// just return stored public value to support Zeppelin impl\n\t\treturn baseURI;\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, \"zeppelin\", _tokenURI);\n\n\t\t// and update token URI - delegate to ERC721URIStorage\n\t\t_setTokenURI(_tokenId, _tokenURI);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721URIStorage\n\t */\n\tfunction _setTokenURI(uint256 _tokenId, string memory _tokenURI) internal virtual override {\n\t\t// delegate to ERC721URIStorage impl\n\t\treturn super._setTokenURI(_tokenId, _tokenURI);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view virtual override(ERC721, ERC721URIStorage) returns (string memory) {\n\t\t// delegate to ERC721URIStorage impl\n\t\treturn ERC721URIStorage.tokenURI(_tokenId);\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public view virtual override returns (bool) {\n\t\t// delegate to super implementation\n\t\treturn _exists(_tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public virtual override {\n\t\t// mint token - delegate to `_mint`\n\t\t_mint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public virtual override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId, _data);\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public virtual override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public virtual override {\n\t\t// burn token - delegate to `_burn`\n\t\t_burn(_tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _mint(address _to, uint256 _tokenId) internal virtual override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// delegate to super implementation\n\t\tsuper._mint(_to, _tokenId);\n\n\t\t// emit an additional event to better track who performed the operation\n\t\temit Minted(msg.sender, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _burn(uint256 _tokenId) internal virtual override(ERC721, ERC721URIStorage) {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(msg.sender == _from\n\t\t\t     || msg.sender == getApproved(_tokenId)\n\t\t\t     || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// delegate to the super implementation with URI burning\n\t\tERC721URIStorage._burn(_tokenId);\n\n\t\t// emit an additional event to better track who performed the operation\n\t\temit Burnt(msg.sender, _from, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _tokenId\n\t) internal virtual override(ERC721, ERC721Enumerable) {\n\t\t// for transfers only - verify if transfers are enabled\n\t\trequire(_from == address(0) || _to == address(0) // won't affect minting/burning\n\t\t     || _from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// delegate to ERC721Enumerable impl\n\t\tERC721Enumerable._beforeTokenTransfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\n\t *      the tokens are rescued via `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transfer(_to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transfer(_to, _value)`\n\t * @param _value value to transfer in `transfer(_to, _value)`\n\t */\n\tfunction rescueErc20(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC20(_contract).safeTransfer(_to, _value);\n\t}\n}\n"
    },
    "contracts/interfaces/ERC20Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title EIP-20: ERC-20 Token Standard\n *\n * @notice The ERC-20 (Ethereum Request for Comments 20), proposed by Fabian Vogelsteller in November 2015,\n *      is a Token Standard that implements an API for tokens within Smart Contracts.\n *\n * @notice It provides functionalities like to transfer tokens from one account to another,\n *      to get the current token balance of an account and also the total supply of the token available on the network.\n *      Besides these it also has some other functionalities like to approve that an amount of\n *      token from an account can be spent by a third party account.\n *\n * @notice If a Smart Contract implements the following methods and events it can be called an ERC-20 Token\n *      Contract and, once deployed, it will be responsible to keep track of the created tokens on Ethereum.\n *\n * @notice See https://ethereum.org/en/developers/docs/standards/tokens/erc-20/\n * @notice See https://eips.ethereum.org/EIPS/eip-20\n */\ninterface ERC20 {\n\t/**\n\t * @dev Fired in transfer(), transferFrom() to indicate that token transfer happened\n\t *\n\t * @param from an address tokens were consumed from\n\t * @param to an address tokens were sent to\n\t * @param value number of tokens transferred\n\t */\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in approve() to indicate an approval event happened\n\t *\n\t * @param owner an address which granted a permission to transfer\n\t *      tokens on its behalf\n\t * @param spender an address which received a permission to transfer\n\t *      tokens on behalf of the owner `_owner`\n\t * @param value amount of tokens granted to transfer on behalf\n\t */\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\n\n\t/**\n\t * @return name of the token (ex.: USD Coin)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function name() external view returns (string memory);\n\n\t/**\n\t * @return symbol of the token (ex.: USDC)\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function symbol() external view returns (string memory);\n\n\t/**\n\t * @dev Returns the number of decimals used to get its user representation.\n\t *      For example, if `decimals` equals `2`, a balance of `505` tokens should\n\t *      be displayed to a user as `5,05` (`505 / 10 ** 2`).\n\t *\n\t * @dev Tokens usually opt for a value of 18, imitating the relationship between\n\t *      Ether and Wei. This is the value {ERC20} uses, unless this function is\n\t *      overridden;\n\t *\n\t * @dev NOTE: This information is only used for _display_ purposes: it in\n\t *      no way affects any of the arithmetic of the contract, including\n\t *      {IERC20-balanceOf} and {IERC20-transfer}.\n\t *\n\t * @return token decimals\n\t */\n\t// OPTIONAL - This method can be used to improve usability,\n\t// but interfaces and other contracts MUST NOT expect these values to be present.\n\t// function decimals() external view returns (uint8);\n\n\t/**\n\t * @return the amount of tokens in existence\n\t */\n\tfunction totalSupply() external view returns (uint256);\n\n\t/**\n\t * @notice Gets the balance of a particular address\n\t *\n\t * @param _owner the address to query the the balance for\n\t * @return balance an amount of tokens owned by the address specified\n\t */\n\tfunction balanceOf(address _owner) external view returns (uint256 balance);\n\n\t/**\n\t * @notice Transfers some tokens to an external address or a smart contract\n\t *\n\t * @dev Called by token owner (an address which has a\n\t *      positive token balance tracked by this smart contract)\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * self address or\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transfer(address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Transfers some tokens on behalf of address `_from' (token owner)\n\t *      to some other address `_to`\n\t *\n\t * @dev Called by token owner on his own or approved address,\n\t *      an address approved earlier by token owner to\n\t *      transfer some amount of tokens on its behalf\n\t * @dev Throws on any error like\n\t *      * insufficient token balance or\n\t *      * incorrect `_to` address:\n\t *          * zero address or\n\t *          * same as `_from` address (self transfer)\n\t *          * smart contract which doesn't support ERC20\n\t *\n\t * @param _from token owner which approved caller (transaction sender)\n\t *      to transfer `_value` of tokens on its behalf\n\t * @param _to an address to transfer tokens to,\n\t *      must be either an external address or a smart contract,\n\t *      compliant with the ERC20 standard\n\t * @param _value amount of tokens to be transferred,, zero\n\t *      value is allowed\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Approves address called `_spender` to transfer some amount\n\t *      of tokens on behalf of the owner (transaction sender)\n\t *\n\t * @dev Transaction sender must not necessarily own any tokens to grant the permission\n\t *\n\t * @param _spender an address approved by the caller (token owner)\n\t *      to spend some tokens on its behalf\n\t * @param _value an amount of tokens spender `_spender` is allowed to\n\t *      transfer on behalf of the token owner\n\t * @return success true on success, throws otherwise\n\t */\n\tfunction approve(address _spender, uint256 _value) external returns (bool success);\n\n\t/**\n\t * @notice Returns the amount which _spender is still allowed to withdraw from _owner.\n\t *\n\t * @dev A function to check an amount of tokens owner approved\n\t *      to transfer on its behalf by some other address called \"spender\"\n\t *\n\t * @param _owner an address which approves transferring some tokens on its behalf\n\t * @param _spender an address approved to transfer some tokens on behalf\n\t * @return remaining an amount of tokens approved address `_spender` can transfer on behalf\n\t *      of token owner `_owner`\n\t */\n\tfunction allowance(address _owner, address _spender) external view returns (uint256 remaining);\n}\n"
    },
    "contracts/interfaces/ERC721SpecExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Mintable ERC721 Extension\n *\n * @notice Defines mint capabilities for ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface MintableERC721 {\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t *\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) external view returns (bool);\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) external;\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) external;\n\n}\n\n/**\n * @title Batch Mintable ERC721 Extension\n *\n * @notice Defines batch minting capabilities for ERC721 tokens.\n *      This interface should be treated as a definition of what mintable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface BatchMintable {\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMintBatch` instead of `mintBatch`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _tokenId ID of the first token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction mintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n) external;\n\n\t/**\n\t * @dev Creates new tokens starting with token ID specified\n\t *      and assigns an ownership `_to` for these tokens\n\t *\n\t * @dev Token IDs to be minted: [_tokenId, _tokenId + n)\n\t *\n\t * @dev n must be greater or equal 2: `n > 1`\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Should have a restricted access handled by the implementation\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param n how many tokens to mint, sequentially increasing the _tokenId\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMintBatch(address _to, uint256 _tokenId, uint256 n, bytes memory _data) external;\n}\n\n/**\n * @title Burnable ERC721 Extension\n *\n * @notice Defines burn capabilities for ERC721 tokens.\n *      This interface should be treated as a definition of what burnable means for ERC721\n *\n * @author Basil Gorin\n */\ninterface BurnableERC721 {\n\t/**\n\t * @notice Destroys the token with token ID specified\n\t *\n\t * @dev Should be accessible publicly by token owners.\n\t *      May have a restricted access handled by the implementation\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) external;\n}\n"
    },
    "contracts/interfaces/IdentifiableSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Identifiable Token\n *\n * @notice Marker interface for the smart contracts having TOKEN_UID public property,\n *      usually these are ERC20/ERC721/ERC1155 token smart contracts\n *\n * @dev TOKEN_UID is used as an enhancement to ERC165 and helps better identifying\n *      deployed smart contracts\n *\n * @author Basil Gorin\n */\ninterface IdentifiableToken {\n\t/**\n\t * @dev Smart contract unique identifier, a random number\n\t *\n\t * @dev Should be regenerated each time smart contact source code is changed\n\t *      and changes smart contract itself is to be redeployed\n\t *\n\t * @dev Generated using https://www.random.org/bytes/\n\t * @dev Example value: 0x0bcafe95bec2350659433fc61cb9c4fbe18719da00059d525154dfe0d6e8c8fd\n\t */\n\tfunction TOKEN_UID() external view returns (uint256);\n}\n"
    },
    "contracts/lib/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\n/**\n * @title SafeERC20 by OpenZeppelin\n *\n * @dev Wrappers around ERC20 operations that throw on failure\n *      (when the token contract returns false).\n *      Tokens that return no value (and instead revert or throw on failure)\n *      are also supported, non-reverting calls are assumed to be successful.\n * @dev To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\n *      which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n *\n * @author OpenZeppelin\n */\nlibrary SafeERC20 {\n\t// using Address.functionCall for addresses\n\tusing Address for address;\n\n\t/**\n\t * @dev ERC20.transfer wrapper\n\t *\n\t * @param token ERC20 instance\n\t * @param to ERC20.transfer to\n\t * @param value ERC20.transfer value\n\t */\n\tfunction safeTransfer(ERC20 token, address to, uint256 value) internal {\n\t\t// delegate to `_callOptionalReturn`\n\t\t_callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n\t}\n\n\t/**\n\t * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n\t * on the return value: the return value is optional (but if data is returned, it must not be false).\n\t * @param token The token targeted by the call.\n\t * @param data The call data (encoded using abi.encode or one of its variants).\n\t */\n\tfunction _callOptionalReturn(ERC20 token, bytes memory data) private {\n\t\t// We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n\t\t// we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n\t\t// the target address contains contract code and also asserts for success in the low-level call.\n\n\t\t// execute function call and get the return data\n\t\tbytes memory retData = address(token).functionCall(data, \"ERC20 low-level call failed\");\n\t\t// return data is optional\n\t\tif(retData.length > 0) {\n\t\t\trequire(abi.decode(retData, (bool)), \"ERC20 transfer failed\");\n\t\t}\n\t}\n}\n"
    },
    "contracts/utils/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Access Control List\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @author Basil Gorin\n */\nabstract contract AccessControl {\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @notice Creates an access control instance,  setting the contract owner to have full privileges\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tconstructor(address _owner) {\n\t\t// contract creator has full privileges\n\t\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/token/ERC20Impl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/IdentifiableSpec.sol\";\nimport \"../utils/AccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n/**\n * @title Simplistic ERC20 Implementation\n *\n * @notice Zeppelin based ERC20 implementation with minting/burning support,\n *      ERC165 support, and AccessControl capabilities\n *\n * @author Basil Gorin\n */\nabstract contract ERC20Impl is IdentifiableToken, IERC165, ERC20, AccessControl {\n\t/**\n\t * @notice Enables ERC20 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transfer()` function to succeed\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC20 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed\n\t * @dev Token owner must call `approve()` first to authorize\n\t *      the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @dev Fired in _mint() and all the dependent functions like mint(), safeMint()\n\t *\n\t * @param by an address which executed update\n\t * @param to an address tokens ware minted to\n\t * @param value amount of tokens minted\n\t */\n\tevent Minted(address indexed by, address indexed to, uint256 value);\n\n\t/**\n\t * @dev Fired in _burn() and all the dependent functions like burn()\n\t *\n\t * @param by an address which executed update\n\t * @param from an address tokens were burnt from\n\t * @param value amount of tokens burnt\n\t */\n\tevent Burnt(address indexed by, address indexed from, uint256 value);\n\n\t/**\n\t * @dev Creates/deploys an ERC20 token\n\t *\n\t * @param _name token name\n\t * @param _symbol token symbol\n\t */\n\tconstructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) AccessControl(msg.sender) {}\n\n\t/**\n\t * @inheritdoc IERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// reconstruct from current interface(s) and super interface(s) (if any)\n\t\treturn interfaceId == type(IERC165).interfaceId || interfaceId == type(IERC20).interfaceId;\n\t}\n\n\t/**\n\t * @dev Mints (creates) some tokens to address specified\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @dev Throws on overflow, if totalSupply + _value doesn't fit into uint256\n\t *\n\t * @param _to an address to mint tokens to\n\t * @param _value an amount of tokens to mint (create)\n\t */\n\tfunction mint(address _to, uint256 _value) public virtual {\n\t\t// delegate to Zeppelin impl\n\t\t_mint(_to, _value);\n\t}\n\n\t/**\n\t * @dev Burns (destroys) some tokens from the address specified\n\t *\n\t * @dev The value specified is treated as is without taking\n\t *      into account what `decimals` value is\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _from an address to burn some tokens from\n\t * @param _value an amount of tokens to burn (destroy)\n\t */\n\tfunction burn(address _from, uint256 _value) public virtual {\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// in case of burn on behalf\n\t\t\tif(_from != msg.sender) {\n\t\t\t\t// read allowance value - the amount of tokens allowed to be burnt - into the stack\n\t\t\t\tuint256 _allowance = allowance(_from, msg.sender);\n\n\t\t\t\t// verify sender has an allowance to burn amount of tokens requested\n\t\t\t\trequire(_allowance >= _value, \"burn amount exceeds allowance\");\n\n\t\t\t\t// update the allowance value\n\t\t\t\t_approve(_from, msg.sender, _allowance - _value);\n\t\t\t}\n\t\t}\n\n\t\t// delegate to Zeppelin impl\n\t\t_burn(_from, _value);\n\n\t\t// emit an additional event to better track who performed the operation\n\t\temit Burnt(msg.sender, _from, _value);\n\t}\n\n\t/**\n\t * @inheritdoc ERC20\n\t */\n\tfunction _mint(address _to, uint256 _value) internal virtual override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// delegate to super implementation\n\t\tsuper._mint(_to, _value);\n\n\t\t// emit an additional event to better track who performed the operation\n\t\temit Minted(msg.sender, _to, _value);\n\t}\n\n\t/**\n\t * @inheritdoc ERC20\n\t */\n\tfunction _beforeTokenTransfer(address _from, address _to, uint256 _value) internal virtual override {\n\t\t// for transfers only - verify if transfers are enabled\n\t\trequire(_from == address(0) || _to == address(0) // won't affect minting/burning\n\t\t     || _from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// delegate to super impl\n\t\tsuper._beforeTokenTransfer(_from, _to, _value);\n\t}\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n\n        uint256 currentAllowance = _allowances[sender][_msgSender()];\n        require(currentAllowance >= amount, \"ERC20: transfer amount exceeds allowance\");\n        unchecked {\n            _approve(sender, _msgSender(), currentAllowance - amount);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender] + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        uint256 currentAllowance = _allowances[_msgSender()][spender];\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(_msgSender(), spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `sender` to `recipient`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        uint256 senderBalance = _balances[sender];\n        require(senderBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[sender] = senderBalance - amount;\n        }\n        _balances[recipient] += amount;\n\n        emit Transfer(sender, recipient, amount);\n\n        _afterTokenTransfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/mocks/AccessControlMocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../utils/AccessControl.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\n\n/**\n * @title Access Control Mock\n *\n * @notice Used to test the AccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract AccessControlMock is AccessControl {\n\t// set contract owner to the deployer address\n\tconstructor() AccessControl(msg.sender) {}\n}\n\n/**\n * @title Upgradeable Access Control Mock\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract UpgradeableAccessControlMock is UpgradeableAccessControl {\n\t// v1 identifier\n\tstring public v1;\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * param _owner smart contract owner having full privileges\n\t */\n\tfunction postConstruct() public virtual initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// self init\n\t\tv1 = \"v1\";\n\t}\n}\n\n/**\n * @title Upgradeable Access Control Mock 2\n *\n * @notice Used to test the UpgradeableAccessControl core functionality\n *\n * @author Basil Gorin\n */\ncontract UpgradeableAccessControlMock2 is UpgradeableAccessControlMock {\n\t// v2 identifier\n\tstring public v2;\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * param _owner smart contract owner having full privileges\n\t */\n\tfunction postConstruct() public virtual override initializer {\n\t\t// execute parent initializer\n\t\t_postConstruct(msg.sender);\n\n\t\t// self init\n\t\tv2 = \"v2\";\n\t}\n}\n"
    },
    "contracts/utils/UpgradeableAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\n/**\n * @title Upgradeable Access Control List // ERC1967Proxy\n *\n * @notice Access control smart contract provides an API to check\n *      if a specific operation is permitted globally and/or\n *      if a particular user has a permission to execute it.\n *\n * @notice It deals with two main entities: features and roles.\n *\n * @notice Features are designed to be used to enable/disable public functions\n *      of the smart contract (used by a wide audience).\n * @notice User roles are designed to control the access to restricted functions\n *      of the smart contract (used by a limited set of maintainers).\n *\n * @notice Terms \"role\", \"permissions\" and \"set of permissions\" have equal meaning\n *      in the documentation text and may be used interchangeably.\n * @notice Terms \"permission\", \"single permission\" implies only one permission bit set.\n *\n * @notice Access manager is a special role which allows to grant/revoke other roles.\n *      Access managers can only grant/revoke permissions which they have themselves.\n *      As an example, access manager with no other roles set can only grant/revoke its own\n *      access manager permission and nothing else.\n *\n * @notice Access manager permission should be treated carefully, as a super admin permission:\n *      Access manager with even no other permission can interfere with another account by\n *      granting own access manager permission to it and effectively creating more powerful\n *      permission set than its own.\n *\n * @dev Both current and OpenZeppelin AccessControl implementations feature a similar API\n *      to check/know \"who is allowed to do this thing\".\n * @dev Zeppelin implementation is more flexible:\n *      - it allows setting unlimited number of roles, while current is limited to 256 different roles\n *      - it allows setting an admin for each role, while current allows having only one global admin\n * @dev Current implementation is more lightweight:\n *      - it uses only 1 bit per role, while Zeppelin uses 256 bits\n *      - it allows setting up to 256 roles at once, in a single transaction, while Zeppelin allows\n *        setting only one role in a single transaction\n *\n * @dev This smart contract is designed to be inherited by other\n *      smart contracts which require access control management capabilities.\n *\n * @dev Access manager permission has a bit 255 set.\n *      This bit must not be used by inheriting contracts for any other permissions/features.\n *\n * @dev This is an upgradeable version of the ACL, based on Zeppelin implementation for ERC1967,\n *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n *      see https://forum.openzeppelin.com/t/uups-proxies-tutorial-solidity-javascript/7786\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableAccessControl is UUPSUpgradeable {\n\t/**\n\t * @notice Privileged addresses with defined roles/permissions\n\t * @notice In the context of ERC20/ERC721 tokens these can be permissions to\n\t *      allow minting or burning tokens, transferring on behalf and so on\n\t *\n\t * @dev Maps user address to the permissions bitmask (role), where each bit\n\t *      represents a permission\n\t * @dev Bitmask 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\t *      represents all possible permissions\n\t * @dev 'This' address mapping represents global features of the smart contract\n\t */\n\tmapping(address => uint256) public userRoles;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Access manager is responsible for assigning the roles to users,\n\t *      enabling/disabling global features of the smart contract\n\t * @notice Access manager can add, remove and update user roles,\n\t *      remove and update global features\n\t *\n\t * @dev Role ROLE_ACCESS_MANAGER allows modifying user roles and global features\n\t * @dev Role ROLE_ACCESS_MANAGER has single bit at position 255 enabled\n\t */\n\tuint256 public constant ROLE_ACCESS_MANAGER = 0x8000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @notice Upgrade manager is responsible for smart contract upgrades,\n\t *      see https://docs.openzeppelin.com/contracts/4.x/api/proxy#UUPSUpgradeable\n\t *      see https://docs.openzeppelin.com/contracts/4.x/upgradeable\n\t *\n\t * @dev Role ROLE_UPGRADE_MANAGER allows passing the _authorizeUpgrade() check\n\t * @dev Role ROLE_UPGRADE_MANAGER has single bit at position 254 enabled\n\t */\n\tuint256 public constant ROLE_UPGRADE_MANAGER = 0x4000000000000000000000000000000000000000000000000000000000000000;\n\n\t/**\n\t * @dev Bitmask representing all the possible permissions (super admin role)\n\t * @dev Has all the bits are enabled (2^256 - 1 value)\n\t */\n\tuint256 private constant FULL_PRIVILEGES_MASK = type(uint256).max; // before 0.8.0: uint256(-1) overflows to 0xFFFF...\n\n\t/**\n\t * @dev Fired in updateRole() and updateFeatures()\n\t *\n\t * @param _by operator which called the function\n\t * @param _to address which was granted/revoked permissions\n\t * @param _requested permissions requested\n\t * @param _actual permissions effectively set\n\t */\n\tevent RoleUpdated(address indexed _by, address indexed _to, uint256 _requested, uint256 _actual);\n\n\t/**\n\t * @dev UUPS initializer, sets the contract owner to have full privileges\n\t *\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(address _owner) internal virtual initializer {\n\t\t// grant owner full privileges\n\t\tuserRoles[_owner] = FULL_PRIVILEGES_MASK;\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, _owner, FULL_PRIVILEGES_MASK, FULL_PRIVILEGES_MASK);\n\t}\n\n\t/**\n\t * @notice Returns an address of the implementation smart contract,\n\t *      see ERC1967Upgrade._getImplementation()\n\t *\n\t * @return the current implementation address\n\t */\n\tfunction getImplementation() public view virtual returns (address) {\n\t\t// delegate to `ERC1967Upgrade._getImplementation()`\n\t\treturn _getImplementation();\n\t}\n\n\t/**\n\t * @notice Retrieves globally set of features enabled\n\t *\n\t * @dev Effectively reads userRoles role for the contract itself\n\t *\n\t * @return 256-bit bitmask of the features enabled\n\t */\n\tfunction features() public view returns (uint256) {\n\t\t// features are stored in 'this' address  mapping of `userRoles` structure\n\t\treturn userRoles[address(this)];\n\t}\n\n\t/**\n\t * @notice Updates set of the globally enabled features (`features`),\n\t *      taking into account sender's permissions\n\t *\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t * @dev Function is left for backward compatibility with older versions\n\t *\n\t * @param _mask bitmask representing a set of features to enable/disable\n\t */\n\tfunction updateFeatures(uint256 _mask) public {\n\t\t// delegate call to `updateRole`\n\t\tupdateRole(address(this), _mask);\n\t}\n\n\t/**\n\t * @notice Updates set of permissions (role) for a given user,\n\t *      taking into account sender's permissions.\n\t *\n\t * @dev Setting role to zero is equivalent to removing an all permissions\n\t * @dev Setting role to `FULL_PRIVILEGES_MASK` is equivalent to\n\t *      copying senders' permissions (role) to the user\n\t * @dev Requires transaction sender to have `ROLE_ACCESS_MANAGER` permission\n\t *\n\t * @param operator address of a user to alter permissions for or zero\n\t *      to alter global features of the smart contract\n\t * @param role bitmask representing a set of permissions to\n\t *      enable/disable for a user specified\n\t */\n\tfunction updateRole(address operator, uint256 role) public {\n\t\t// caller must have a permission to update user roles\n\t\trequire(isSenderInRole(ROLE_ACCESS_MANAGER), \"access denied\");\n\n\t\t// evaluate the role and reassign it\n\t\tuserRoles[operator] = evaluateBy(msg.sender, userRoles[operator], role);\n\n\t\t// fire an event\n\t\temit RoleUpdated(msg.sender, operator, role, userRoles[operator]);\n\t}\n\n\t/**\n\t * @notice Determines the permission bitmask an operator can set on the\n\t *      target permission set\n\t * @notice Used to calculate the permission bitmask to be set when requested\n\t *     in `updateRole` and `updateFeatures` functions\n\t *\n\t * @dev Calculated based on:\n\t *      1) operator's own permission set read from userRoles[operator]\n\t *      2) target permission set - what is already set on the target\n\t *      3) desired permission set - what do we want set target to\n\t *\n\t * @dev Corner cases:\n\t *      1) Operator is super admin and its permission set is `FULL_PRIVILEGES_MASK`:\n\t *        `desired` bitset is returned regardless of the `target` permission set value\n\t *        (what operator sets is what they get)\n\t *      2) Operator with no permissions (zero bitset):\n\t *        `target` bitset is returned regardless of the `desired` value\n\t *        (operator has no authority and cannot modify anything)\n\t *\n\t * @dev Example:\n\t *      Consider an operator with the permissions bitmask     00001111\n\t *      is about to modify the target permission set          01010101\n\t *      Operator wants to set that permission set to          00110011\n\t *      Based on their role, an operator has the permissions\n\t *      to update only lowest 4 bits on the target, meaning that\n\t *      high 4 bits of the target set in this example is left\n\t *      unchanged and low 4 bits get changed as desired:      01010011\n\t *\n\t * @param operator address of the contract operator which is about to set the permissions\n\t * @param target input set of permissions to operator is going to modify\n\t * @param desired desired set of permissions operator would like to set\n\t * @return resulting set of permissions given operator will set\n\t */\n\tfunction evaluateBy(address operator, uint256 target, uint256 desired) public view returns (uint256) {\n\t\t// read operator's permissions\n\t\tuint256 p = userRoles[operator];\n\n\t\t// taking into account operator's permissions,\n\t\t// 1) enable the permissions desired on the `target`\n\t\ttarget |= p & desired;\n\t\t// 2) disable the permissions desired on the `target`\n\t\ttarget &= FULL_PRIVILEGES_MASK ^ (p & (FULL_PRIVILEGES_MASK ^ desired));\n\n\t\t// return calculated result\n\t\treturn target;\n\t}\n\n\t/**\n\t * @notice Checks if requested set of features is enabled globally on the contract\n\t *\n\t * @param required set of features to check against\n\t * @return true if all the features requested are enabled, false otherwise\n\t */\n\tfunction isFeatureEnabled(uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing `features` property\n\t\treturn __hasRole(features(), required);\n\t}\n\n\t/**\n\t * @notice Checks if transaction sender `msg.sender` has all the permissions required\n\t *\n\t * @param required set of permissions (role) to check against\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isSenderInRole(uint256 required) public view returns (bool) {\n\t\t// delegate call to `isOperatorInRole`, passing transaction sender\n\t\treturn isOperatorInRole(msg.sender, required);\n\t}\n\n\t/**\n\t * @notice Checks if operator has all the permissions (role) required\n\t *\n\t * @param operator address of the user to check role for\n\t * @param required set of permissions (role) to check\n\t * @return true if all the permissions requested are enabled, false otherwise\n\t */\n\tfunction isOperatorInRole(address operator, uint256 required) public view returns (bool) {\n\t\t// delegate call to `__hasRole`, passing operator's permissions (role)\n\t\treturn __hasRole(userRoles[operator], required);\n\t}\n\n\t/**\n\t * @dev Checks if role `actual` contains all the permissions required `required`\n\t *\n\t * @param actual existent role\n\t * @param required required role\n\t * @return true if actual has required role (all permissions), false otherwise\n\t */\n\tfunction __hasRole(uint256 actual, uint256 required) internal pure returns (bool) {\n\t\t// check the bitmask for the role required and return the result\n\t\treturn actual & required == required;\n\t}\n\n\t/**\n\t * @inheritdoc UUPSUpgradeable\n\t */\n\tfunction _authorizeUpgrade(address) internal virtual override {\n\t\t// caller must have a permission to upgrade the contract\n\t\trequire(isSenderInRole(ROLE_UPGRADE_MANAGER), \"access denied\");\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n        __UUPSUpgradeable_init_unchained();\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallSecure(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n        __ERC1967Upgrade_init_unchained();\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallSecure(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        address oldImplementation = _getImplementation();\n\n        // Initial upgrade and setup call\n        _setImplementation(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n\n        // Perform rollback test if not already in progress\n        StorageSlotUpgradeable.BooleanSlot storage rollbackTesting = StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT);\n        if (!rollbackTesting.value) {\n            // Trigger rollback using upgradeTo from the new implementation\n            rollbackTesting.value = true;\n            _functionDelegateCall(\n                newImplementation,\n                abi.encodeWithSignature(\"upgradeTo(address)\", oldImplementation)\n            );\n            rollbackTesting.value = false;\n            // Check rollback was effective\n            require(oldImplementation == _getImplementation(), \"ERC1967Upgrade: upgrade breaks further upgrades\");\n            // Finally reset to the new implementation and log the upgrade\n            _upgradeTo(newImplementation);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since a proxied contract can't have a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To initialize the implementation contract, you can either invoke the\n * initializer manually, or you can include a constructor to automatically mark it as initialized when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() initializer {}\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     */\n    bool private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Modifier to protect an initializer function from being invoked twice.\n     */\n    modifier initializer() {\n        // If the contract is initializing we ignore whether _initialized is set in order to support multiple\n        // inheritance patterns, but we only do this in the context of a constructor, because in other contexts the\n        // contract may have been reentered.\n        require(_initializing ? _isConstructor() : !_initialized, \"Initializable: contract is already initialized\");\n\n        bool isTopLevelCall = !_initializing;\n        if (isTopLevelCall) {\n            _initializing = true;\n            _initialized = true;\n        }\n\n        _;\n\n        if (isTopLevelCall) {\n            _initializing = false;\n        }\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} modifier, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    function _isConstructor() private view returns (bool) {\n        return !AddressUpgradeable.isContract(address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/protocol/LandSale.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../interfaces/LandERC721Spec.sol\";\nimport \"../interfaces/IdentifiableSpec.sol\";\nimport \"../interfaces/PriceOracleSpec.sol\";\nimport \"../lib/LandLib.sol\";\nimport \"../lib/SafeERC20.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\n\n/**\n * @title Land Sale\n *\n * @notice Enables the Land NFT sale via dutch auction mechanism\n *\n * @notice The proposed volume of land is approximately 100,000 plots, split amongst the 7 regions.\n *      The volume is released over a series of staggered sales with the first sale featuring\n *      about 20,000 land plots (tokens).\n *\n * @notice Land plots are sold in sequences, each sequence groups tokens which are sold in parallel.\n *      Sequences start selling one by one with the configurable time interval between their start.\n *      A sequence is available for a sale for a fixed (configurable) amount of time, meaning they\n *      can overlap (tokens from several sequences are available on sale simultaneously) if this\n *      amount of time is bigger than interval between sequences start.\n *\n * @notice The sale operates in a configurable time interval which should be aligned with the\n *      total number of sequences, their duration, and start interval.\n *      Sale smart contract has no idea of the total number of sequences and doesn't validate\n *      if these timings are correctly aligned.\n *\n * @notice Starting prices of the plots are defined by the plot tier in ETH, and are configurable\n *      within the sale contract per tier ID.\n *      Token price declines over time exponentially, price halving time is configurable.\n *      The exponential price decline simulates the price drop requirement which may be formulated\n *      something like \"the price drops by 'x' % every 'y' minutes\".\n *      For example, if x = 2, and y = 1, \"the price drops by 2% every minute\", the halving\n *      time is around 34 minutes.\n *\n * @notice Sale accepts ETH and sILV as a payment currency, sILV price is supplied by on-chain\n *      price oracle (sILV price is assumed to be equal to ILV price)\n *\n * @notice The data required to mint a plot includes (see `PlotData` struct):\n *      - token ID, defines a unique ID for the land plot used as ERC721 token ID\n *      - sequence ID, defines the time frame when the plot is available for sale\n *      - region ID (1 - 7), determines which tileset to use in game,\n *      - coordinates (x, y) on the overall world map, indicating which grid position the land sits in,\n *      - tier ID (1 - 5), the rarity of the land, tier is used to create the list of sites,\n *      - size (w, h), defines an internal coordinate system within a plot,\n *\n * @notice Since minting a plot requires at least 32 bytes of data and due to a significant\n *      amount of plots to be minted (about 100,000), pre-storing this data on-chain\n *      is not a viable option (2,000,000,000 of gas only to pay for the storage).\n *      Instead, we represent the whole land plot data collection on sale as a Merkle tree\n *      structure and store the root of the Merkle tree on-chain.\n *      To buy a particular plot, the buyer must know the entire collection and be able to\n *      generate and present the Merkle proof for this particular plot.\n *\n * @notice The input data is a collection of `PlotData` structures; the Merkle tree is built out\n *      from this collection, and the tree root is stored on the contract by the data manager.\n *      When buying a plot, the buyer also specifies the Merkle proof for a plot data to mint.\n *\n * @notice Layer 2 support (ex. IMX minting)\n *      Sale contract supports both L1 and L2 sales.\n *      L1 sale mints the token in layer 1 network (Ethereum mainnet) immediately,\n *      in the same transaction it is bought.\n *      L2 sale doesn't mint the token and just emits an event containing token metadata and owner;\n *      this event is then picked by the off-chain process (daemon) which mints the token in a\n *      layer 2 network (IMX, https://www.immutable.com/)\n *\n * @dev A note on randomness\n *      Current implementation uses \"on-chain randomness\" to mint a land plot, which is calculated\n *      as a keccak256 hash of some available parameters, like token ID, buyer address, and block\n *      timestamp.\n *      This can be relatively easy manipulated not only by miners, but even by clients wrapping\n *      their transactions into the smart contract code when buying (calling a `buy` function).\n *      It is considered normal and acceptable from the security point of view since the value\n *      of such manipulation is low compared to the transaction cost.\n *      This situation can change, however, in the future sales when more information on the game\n *      is available, and when it becomes more clear how resource types and their positions\n *      affect the game mechanics, and can be used to benefit players.\n *\n * @dev A note on timestamps\n *      Current implementation uses uint32 to represent unix timestamp, and time intervals,\n *      it is not designed to be used after February 7, 2106, 06:28:15 GMT (unix time 0xFFFFFFFF)\n *\n * @dev Merkle proof verification is based on OpenZeppelin implementation, see\n *      https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\n *\n * @author Basil Gorin\n */\ncontract LandSale is UpgradeableAccessControl {\n\t// using ERC20.transfer wrapper from OpenZeppelin adopted SafeERC20\n\tusing SafeERC20 for ERC20;\n\t// Use Zeppelin MerkleProof Library to verify Merkle proofs\n\tusing MerkleProof for bytes32[];\n\t// Use Land Library to pack `PlotStore` struct to uint256\n\tusing LandLib for LandLib.PlotStore;\n\n\t/**\n\t * @title Plot Data, a.k.a. Sale Data\n\t *\n\t * @notice Data structure modeling the data entry required to mint a single plot.\n\t *      The contract is initialized with the Merkle root of the plots collection Merkle tree.\n\t * @dev When buying a plot this data structure must be supplied together with the\n\t *      Merkle proof allowing to verify the plot data belongs to the original collection.\n\t */\n\tstruct PlotData {\n\t\t/// @dev Token ID, defines a unique ID for the land plot used as ERC721 token ID\n\t\tuint32 tokenId;\n\t\t/// @dev Sequence ID, defines the time frame when the plot is available for sale\n\t\tuint32 sequenceId;\n\t\t/// @dev Region ID defines the region on the map in IZ\n\t\tuint8 regionId;\n\t\t/// @dev x-coordinate within the region plot\n\t\tuint16 x;\n\t\t/// @dev y-coordinate within the region plot\n\t\tuint16 y;\n\t\t/// @dev Tier ID defines land rarity and number of sites within the plot\n\t\tuint8 tierId;\n\t\t/// @dev Plot size, limits the (x, y) coordinates for the sites\n\t\tuint16 size;\n\t}\n\n\t/**\n\t * @notice Deployed LandERC721 token address to mint tokens of\n\t *      (when they are bought via the sale)\n\t */\n\taddress public targetNftContract;\n\n\t/**\n\t * @notice Deployed sILV (Escrowed Illuvium) ERC20 token address,\n\t *      accepted as a payment option alongside ETH\n\t * @dev Note: sILV ERC20 implementation never returns \"false\" on transfers,\n\t *      it throws instead; we don't use any additional libraries like SafeERC20\n\t *      to transfer sILV therefore\n\t */\n\taddress public sIlvContract;\n\n\t/**\n\t * @notice Land Sale Price Oracle is used to convert the token prices from USD\n\t *      to ETH or sILV (ILV)\n\t */\n\taddress public priceOracle;\n\n\t/**\n\t * @notice Input data root, Merkle tree root for the collection of plot data elements,\n\t *      available on sale\n\t *\n\t * @notice Merkle root effectively \"compresses\" the (potentially) huge collection of elements\n\t *      and allows to store it in a single 256-bits storage slot on-chain\n\t */\n\tbytes32 public root;\n\n\t/**\n\t * @dev Sale start unix timestamp, scheduled sale start, the time when the sale\n\t *      is scheduled to start, this is the time when sale activates,\n\t *      the time when the first sequence sale starts, that is\n\t *      when tokens of the first sequence become available on sale\n\t * @dev The sale is active after the start (inclusive)\n\t */\n\tuint32 public saleStart;\n\n\t/**\n\t * @dev Sale end unix timestamp, this is the time when sale deactivates,\n\t *      and tokens of the last sequence become unavailable\n\t * @dev The sale is active before the end (exclusive)\n\t */\n\tuint32 public saleEnd;\n\n\t/**\n\t * @dev Price halving time, the time required for a token price to reduce to the\n\t *      half of its initial value\n\t * @dev Defined in seconds\n\t */\n\tuint32 public halvingTime;\n\n\t/**\n\t * @dev Time flow quantum, price update interval, used by the price calculation algorithm,\n\t *      the time is rounded down to be multiple of quantum when performing price calculations;\n\t *      setting this value to one effectively disables its effect;\n\t * @dev Defined in seconds\n\t */\n\tuint32 public timeFlowQuantum;\n\n\t/**\n\t * @dev Sequence duration, time limit of how long a token / sequence can be available\n\t *      for sale, first sequence stops selling at `saleStart + seqDuration`, second\n\t *      sequence stops selling at `saleStart + seqOffset + seqDuration`, and so on\n\t * @dev Defined in seconds\n\t */\n\tuint32 public seqDuration;\n\n\t/**\n\t * @dev Sequence start offset, first sequence starts selling at `saleStart`,\n\t *      second sequence starts at `saleStart + seqOffset`, third at\n\t *      `saleStart + 2 * seqOffset` and so on at `saleStart + n * seqOffset`,\n\t *      where `n` is zero-based sequence ID\n\t * @dev Defined in seconds\n\t */\n\tuint32 public seqOffset;\n\n\t/**\n\t * @dev Sale paused unix timestamp, the time when sale was paused,\n\t *     non-zero value indicates that the sale is currently in a paused state\n\t *     and is not operational\n\t *\n\t * @dev Pausing a sale effectively pauses \"own time\" of the sale, this is achieved\n\t *     by tracking cumulative sale pause duration (see `pauseDuration`) and taking it\n\t *     into account when evaluating current sale time, prices, sequences on sale, etc.\n\t *\n\t * @dev Erased (set to zero) when sale start time is modified (see initialization, `initialize()`)\n\t */\n\tuint32 public pausedAt;\n\n\t/**\n\t * @dev Cumulative sale pause duration, total amount of time sale stayed in a paused state\n\t *      since the last time sale start time was set (see initialization, `initialize()`)\n\t *\n\t * @dev Is increased only when sale is resumed back from the paused state, is not updated\n\t *      when the sale is in a paused state\n\t *\n\t * @dev Defined in seconds\n\t */\n\tuint32 public pauseDuration;\n\n\t/**\n\t * @dev Tier start prices, starting token price for each (zero based) Tier ID,\n\t *      defined in ETH, can be converted into sILV via Uniswap/Sushiswap price oracle,\n\t *      sILV price is defined to be equal to ILV price\n\t */\n\tuint96[] public startPrices;\n\n\t/**\n\t * @dev Sale beneficiary address, if set - used to send funds obtained from the sale;\n\t *      If not set - contract accumulates the funds on its own deployed address\n\t */\n\taddress payable public beneficiary;\n\n\t/**\n\t * @dev A bitmap of minted tokens, required to support L2 sales:\n\t *      when token is not minted in L1 we still need to track it was sold using this bitmap\n\t *\n\t * @dev Bitmap is stored as an array of uint256 data slots, each slot holding\n\t *     256 bits of the entire bitmap.\n\t *     An array itself is stored as a mapping with a zero-index integer key.\n\t *     Each mapping entry represents the state of 256 tokens (each bit corresponds to a\n\t *     single token)\n\t *\n\t * @dev For a token ID `n`,\n\t *      the data slot index `i` is `n / 256`,\n\t *      and bit index within a slot `j` is `n % 256`\n\t */\n\tmapping(uint256 => uint256) public mintedTokens;\n\n\t/**\n\t * @notice Enables the L1 sale, buying tokens in L1 public function\n\t *\n\t * @notice Note: sale could be activated/deactivated by either sale manager, or\n\t *      data manager, since these roles control sale params, and items on sale;\n\t *      However both sale and data managers require some advanced knowledge about\n\t *      the use of the functions they trigger, while switching the \"sale active\"\n\t *      flag is very simple and can be done much more easier\n\t *\n\t * @dev Feature FEATURE_L1_SALE_ACTIVE must be enabled in order for\n\t *      `buyL1()` function to be able to succeed\n\t */\n\tuint32 public constant FEATURE_L1_SALE_ACTIVE = 0x0000_0001;\n\n\t/**\n\t * @notice Enables the L2 sale, buying tokens in L2 public function\n\t *\n\t * @notice Note: sale could be activated/deactivated by either sale manager, or\n\t *      data manager, since these roles control sale params, and items on sale;\n\t *      However both sale and data managers require some advanced knowledge about\n\t *      the use of the functions they trigger, while switching the \"sale active\"\n\t *      flag is very simple and can be done much more easier\n\t *\n\t * @dev Feature FEATURE_L2_SALE_ACTIVE must be enabled in order for\n\t *      `buyL2()` function to be able to succeed\n\t */\n\tuint32 public constant FEATURE_L2_SALE_ACTIVE = 0x0000_0002;\n\n\t/**\n\t * @notice Pause manager is responsible for:\n\t *      - sale pausing (pausing/resuming the sale in case of emergency)\n\t *\n\t * @dev Role ROLE_PAUSE_MANAGER allows sale pausing/resuming via pause() / resume()\n\t */\n\tuint32 public constant ROLE_PAUSE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @notice Data manager is responsible for supplying the valid input plot data collection\n\t *      Merkle root which then can be used to mint tokens, meaning effectively,\n\t *      that data manager may act as a minter on the target NFT contract\n\t *\n\t * @dev Role ROLE_DATA_MANAGER allows setting the Merkle tree root via setInputDataRoot()\n\t */\n\tuint32 public constant ROLE_DATA_MANAGER = 0x0002_0000;\n\n\t/**\n\t * @notice Sale manager is responsible for:\n\t *      - sale initialization (setting up sale timing/pricing parameters)\n\t *\n\t * @dev Role ROLE_SALE_MANAGER allows sale initialization via initialize()\n\t */\n\tuint32 public constant ROLE_SALE_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @notice People do mistake and may send ERC20 tokens by mistake; since\n\t *      NFT smart contract is not designed to accept and hold any ERC20 tokens,\n\t *      it allows the rescue manager to \"rescue\" such lost tokens\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20 tokens accidentally\n\t *      sent to the smart contract, except the sILV which is a payment token\n\t *      and can be withdrawn by the withdrawal manager only\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing any ERC20 tokens stored\n\t *      on the smart contract balance\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0008_0000;\n\n\t/**\n\t * @notice Withdrawal manager is responsible for withdrawing funds obtained in sale\n\t *      from the sale smart contract via pull/push mechanisms:\n\t *      1) Pull: no pre-setup is required, withdrawal manager executes the\n\t *         withdraw function periodically to withdraw funds\n\t *      2) Push: withdrawal manager sets the `beneficiary` address which is used\n\t *         by the smart contract to send funds to when users purchase land NFTs\n\t *\n\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows to set the `beneficiary` address via\n\t *      - setBeneficiary()\n\t * @dev Role ROLE_WITHDRAWAL_MANAGER allows pull withdrawals of funds:\n\t *      - withdraw()\n\t *      - withdrawTo()\n\t */\n\tuint32 public constant ROLE_WITHDRAWAL_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @dev Fired in setInputDataRoot()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _root new Merkle root value\n\t */\n\tevent RootChanged(address indexed _by, bytes32 _root);\n\n\t/**\n\t * @dev Fired in initialize()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _saleStart sale start unix timestamp, and first sequence start time\n\t * @param _saleEnd sale end unix timestamp, should match with the last sequence end time\n\t * @param _halvingTime price halving time (seconds), the time required for a token price\n\t *      to reduce to the half of its initial value\n\t * @param _timeFlowQuantum time flow quantum (seconds), price update interval, used by\n\t *      the price calculation algorithm to update prices\n\t * @param _seqDuration sequence duration (seconds), time limit of how long a token / sequence\n\t *      can be available for sale\n\t * @param _seqOffset sequence start offset (seconds), each sequence starts `_seqOffset`\n\t *      later after the previous one\n\t * @param _startPrices tier start prices (wei), starting token price for each (zero based) Tier ID\n\t */\n\tevent Initialized(\n\t\taddress indexed _by,\n\t\tuint32 _saleStart,\n\t\tuint32 _saleEnd,\n\t\tuint32 _halvingTime,\n\t\tuint32 _timeFlowQuantum,\n\t\tuint32 _seqDuration,\n\t\tuint32 _seqOffset,\n\t\tuint96[] _startPrices\n\t);\n\n\t/**\n\t * @dev Fired in pause()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _pausedAt when the sale was paused (unix timestamp)\n\t */\n\tevent Paused(address indexed _by, uint32 _pausedAt);\n\n\t/**\n\t * @dev Fired in resume(), optionally in initialize() (only if sale start is changed)\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _pausedAt when the sale was paused (unix timestamp)\n\t * @param _resumedAt when the sale was resumed (unix timestamp)\n\t * @param _pauseDuration cumulative sale pause duration (seconds)\n\t */\n\tevent Resumed(address indexed _by, uint32 _pausedAt, uint32 _resumedAt, uint32 _pauseDuration);\n\n\t/**\n\t * @dev Fired in setBeneficiary\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _beneficiary new beneficiary address or zero-address\n\t */\n\tevent BeneficiaryUpdated(address indexed _by, address indexed _beneficiary);\n\n\t/**\n\t * @dev Fired in withdraw() and withdrawTo()\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _to an address which received the funds withdrawn\n\t * @param _eth amount of ETH withdrawn (wei)\n\t * @param _sIlv amount of sILV withdrawn (wei)\n\t */\n\tevent Withdrawn(address indexed _by, address indexed _to, uint256 _eth, uint256 _sIlv);\n\n\t/**\n\t * @dev Fired in buyL1()\n\t *\n\t * @param _by an address which had bought the plot\n\t * @param _tokenId Token ID, part of the off-chain plot metadata supplied externally\n\t * @param _sequenceId Sequence ID, part of the off-chain plot metadata supplied externally\n\t * @param _plot on-chain plot metadata minted token, contains values copied from off-chain\n\t *      plot metadata supplied externally, and generated values such as seed\n\t * @param _eth ETH price of the lot (wei, non-zero)\n\t * @param _sIlv sILV price of the lot (wei, zero if paid in ETH)\n\t */\n\tevent PlotBoughtL1(\n\t\taddress indexed _by,\n\t\tuint32 indexed _tokenId,\n\t\tuint32 indexed _sequenceId,\n\t\tLandLib.PlotStore _plot,\n\t\tuint256 _eth,\n\t\tuint256 _sIlv\n\t);\n\n\t/**\n\t * @dev Fired in buyL2()\n\t *\n\t * @param _by an address which had bought the plot\n\t * @param _tokenId Token ID, part of the off-chain plot metadata supplied externally\n\t * @param _sequenceId Sequence ID, part of the off-chain plot metadata supplied externally\n\t * @param _plot on-chain plot metadata minted token, contains values copied from off-chain\n\t *      plot metadata supplied externally, and generated values such as seed\n\t * @param _eth ETH price of the lot (wei, non-zero)\n\t * @param _sIlv sILV price of the lot (wei, zero if paid in ETH)\n\t */\n\tevent PlotBoughtL2(\n\t\taddress indexed _by,\n\t\tuint32 indexed _tokenId,\n\t\tuint32 indexed _sequenceId,\n\t\tLandLib.PlotStore _plot,\n\t\tuint256 _plotPacked,\n\t\tuint256 _eth,\n\t\tuint256 _sIlv\n\t);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @dev Binds the sale smart contract instance to\n\t *      1) the target NFT smart contract address to be used to mint tokens (Land ERC721),\n\t *      2) sILV (Escrowed Illuvium) contract address to be used as one of the payment options\n\t *      3) Price Oracle contract address to be used to determine ETH/sILV price\n\t *\n\t * @param _nft target NFT smart contract address\n\t * @param _sIlv sILV (Escrowed Illuvium) contract address\n\t * @param _oracle price oracle contract address\n\t */\n\tfunction postConstruct(address _nft, address _sIlv, address _oracle) public virtual initializer {\n\t\t// verify the inputs are set\n\t\trequire(_nft != address(0), \"target contract is not set\");\n\t\trequire(_sIlv != address(0), \"sILV contract is not set\");\n\t\trequire(_oracle != address(0), \"oracle address is not set\");\n\n\t\t// verify the inputs are valid smart contracts of the expected interfaces\n\t\trequire(\n\t\t\tERC165(_nft).supportsInterface(type(ERC721).interfaceId)\n\t\t\t&& ERC165(_nft).supportsInterface(type(MintableERC721).interfaceId)\n\t\t\t&& ERC165(_nft).supportsInterface(type(LandERC721Metadata).interfaceId),\n\t\t\t// note: ImmutableMintableERC721 is not required by the sale\n\t\t\t\"unexpected target type\"\n\t\t);\n\t\trequire(ERC165(_oracle).supportsInterface(type(LandSalePriceOracle).interfaceId), \"unexpected oracle type\");\n\t\t// for the sILV ERC165 check is unavailable, but we can check some ERC20 functions manually\n\t\trequire(ERC20(_sIlv).balanceOf(address(this)) < type(uint256).max, \"sILV.balanceOf failure\");\n\t\trequire(ERC20(_sIlv).transfer(address(0x1), 0), \"sILV.transfer failure\");\n\t\trequire(ERC20(_sIlv).transferFrom(address(this), address(0x1), 0), \"sILV.transferFrom failure\");\n\n\t\t// assign the addresses\n\t\ttargetNftContract = _nft;\n\t\tsIlvContract = _sIlv;\n\t\tpriceOracle = _oracle;\n\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableAccessControl._postConstruct(msg.sender);\n\t}\n\n\t/**\n\t * @dev `startPrices` getter; the getters solidity creates for arrays\n\t *      may be inconvenient to use if we need an entire array to be read\n\t *\n\t * @return `startPrices` as is - as an array of uint96\n\t */\n\tfunction getStartPrices() public view virtual returns (uint96[] memory) {\n\t\t// read `startPrices` array into memory and return\n\t\treturn startPrices;\n\t}\n\n\t/**\n\t * @notice Restricted access function to update input data root (Merkle tree root),\n\t *       and to define, effectively, the tokens to be created by this smart contract\n\t *\n\t * @dev Requires executor to have `ROLE_DATA_MANAGER` permission\n\t *\n\t * @param _root Merkle tree root for the input plot data collection\n\t */\n\tfunction setInputDataRoot(bytes32 _root) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_DATA_MANAGER), \"access denied\");\n\n\t\t// update input data Merkle tree root\n\t\troot = _root;\n\n\t\t// emit an event\n\t\temit RootChanged(msg.sender, _root);\n\t}\n\n\t/**\n\t * @notice Verifies the validity of a plot supplied (namely, if it's registered for the sale)\n\t *      based on the Merkle root of the plot data collection (already defined on the contract),\n\t *      and the Merkle proof supplied to validate the particular plot data\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the plot data collection elements via `web3.utils.soliditySha3`, making sure\n\t *         the packing order and types are exactly as defined in `PlotData` struct\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed collection, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given plot data element the proof is constructed by hashing it (as in step 1),\n\t *         and querying the MerkleTree for a proof, providing the hashed plot data element as a leaf\n\t *\n\t * @dev See also: https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\n\t *\n\t * @param plotData plot data to verify\n\t * @param proof Merkle proof for the plot data supplied\n\t * @return true if plot is valid (belongs to registered collection), false otherwise\n\t */\n\tfunction isPlotValid(PlotData memory plotData, bytes32[] memory proof) public view virtual returns (bool) {\n\t\t// construct Merkle tree leaf from the inputs supplied\n\t\tbytes32 leaf = keccak256(abi.encodePacked(\n\t\t\t\tplotData.tokenId,\n\t\t\t\tplotData.sequenceId,\n\t\t\t\tplotData.regionId,\n\t\t\t\tplotData.x,\n\t\t\t\tplotData.y,\n\t\t\t\tplotData.tierId,\n\t\t\t\tplotData.size\n\t\t\t));\n\n\t\t// verify the proof supplied, and return the verification result\n\t\treturn proof.verify(root, leaf);\n\t}\n\n\t/**\n\t * @dev Restricted access function to set up sale parameters, all at once,\n\t *      or any subset of them\n\t *\n\t * @dev To skip parameter initialization, set it to `-1`,\n\t *      that is a maximum value for unsigned integer of the corresponding type;\n\t *      for `_startPrices` use a single array element with the `-1` value to skip\n\t *\n\t * @dev Example: following initialization will update only `_seqDuration` and `_seqOffset`,\n\t *      leaving the rest of the fields unchanged\n\t *      initialize(\n\t *          0xFFFFFFFF, // `_saleStart` unchanged\n\t *          0xFFFFFFFF, // `_saleEnd` unchanged\n\t *          0xFFFFFFFF, // `_halvingTime` unchanged\n\t *          21600,      // `_seqDuration` updated to 6 hours\n\t *          3600,       // `_seqOffset` updated to 1 hour\n\t *          [0xFFFFFFFFFFFFFFFFFFFFFFFF] // `_startPrices` unchanged\n\t *      )\n\t *\n\t * @dev Sale start and end times should match with the number of sequences,\n\t *      sequence duration and offset, if `n` is number of sequences, then\n\t *      the following equation must hold:\n\t *         `saleStart + (n - 1) * seqOffset + seqDuration = saleEnd`\n\t *      Note: `n` is unknown to the sale contract and there is no way for it\n\t *      to accurately validate other parameters of the equation above\n\t *\n\t * @dev Input params are not validated; to get an idea if these params look valid,\n\t *      refer to `isActive() `function, and it's logic\n\t *\n\t * @dev Requires transaction sender to have `ROLE_SALE_MANAGER` role\n\t *\n\t * @param _saleStart sale start unix timestamp, and first sequence start time\n\t * @param _saleEnd sale end unix timestamp, should match with the last sequence end time\n\t * @param _halvingTime price halving time (seconds), the time required for a token price\n\t *      to reduce to the half of its initial value\n\t * @param _timeFlowQuantum time flow quantum (seconds), price update interval, used by\n\t *      the price calculation algorithm to update prices\n\t * @param _seqDuration sequence duration (seconds), time limit of how long a token / sequence\n\t *      can be available for sale\n\t * @param _seqOffset sequence start offset (seconds), each sequence starts `_seqOffset`\n\t *      later after the previous one\n\t * @param _startPrices tier start prices (wei), starting token price for each (zero based) Tier ID\n\t */\n\tfunction initialize(\n\t\tuint32 _saleStart,           // <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _saleEnd,             // <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _halvingTime,         // <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _timeFlowQuantum,     // <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _seqDuration,         // <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint32 _seqOffset,           // <<<--- keep type in sync with the body type(uint32).max !!!\n\t\tuint96[] memory _startPrices // <<<--- keep type in sync with the body type(uint96).max !!!\n\t) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_SALE_MANAGER), \"access denied\");\n\n\t\t// Note: no input validation at this stage, initial params state is invalid anyway,\n\t\t//       and we're not limiting sale manager to set these params back to this state\n\n\t\t// set/update sale parameters (allowing partial update)\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleStart != type(uint32).max) {\n\t\t\t// update the sale start itself, and\n\t\t\tsaleStart = _saleStart;\n\n\t\t\t// if the sale is in paused state (non-zero `pausedAt`)\n\t\t\tif(pausedAt != 0) {\n\t\t\t\t// emit an event first - to log old `pausedAt` value\n\t\t\t\temit Resumed(msg.sender, pausedAt, now32(), pauseDuration + now32() - pausedAt);\n\n\t\t\t\t// erase `pausedAt`, effectively resuming the sale\n\t\t\t\tpausedAt = 0;\n\t\t\t}\n\n\t\t\t// erase the cumulative pause duration\n\t\t\tpauseDuration = 0;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_saleEnd != type(uint32).max) {\n\t\t\tsaleEnd = _saleEnd;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_halvingTime != type(uint32).max) {\n\t\t\thalvingTime = _halvingTime;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_timeFlowQuantum != type(uint32).max) {\n\t\t\ttimeFlowQuantum = _timeFlowQuantum;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_seqDuration != type(uint32).max) {\n\t\t\tseqDuration = _seqDuration;\n\t\t}\n\t\t// 0xFFFFFFFF, 32 bits\n\t\tif(_seqOffset != type(uint32).max) {\n\t\t\tseqOffset = _seqOffset;\n\t\t}\n\t\t// 0xFFFFFFFFFFFFFFFFFFFFFFFF, 96 bits\n\t\tif(_startPrices.length != 1 || _startPrices[0] != type(uint96).max) {\n\t\t\tstartPrices = _startPrices;\n\t\t}\n\n\t\t// emit an event\n\t\temit Initialized(msg.sender, saleStart, saleEnd, halvingTime, timeFlowQuantum, seqDuration, seqOffset, startPrices);\n\t}\n\n\t/**\n\t * @notice Verifies if sale is in the active state, meaning that it is properly\n\t *      initialized with the sale start/end times, sequence params, etc., and\n\t *      that the current time is within the sale start/end bounds\n\t *\n\t * @notice Doesn't check if the plot data Merkle root `root` is set or not;\n\t *      active sale state doesn't guarantee that an item can be actually bought\n\t *\n\t * @dev The sale is defined as active if all of the below conditions hold:\n\t *      - sale start is now or in the past\n\t *      - sale end is in the future\n\t *      - halving time is not zero\n\t *      - sequence duration is not zero\n\t *      - there is at least one starting price set (zero price is valid)\n\t *\n\t * @return true if sale is active, false otherwise\n\t */\n\tfunction isActive() public view virtual returns (bool) {\n\t\t// calculate sale state based on the internal sale params state and return\n\t\treturn pausedAt == 0\n\t\t\t&& saleStart <= ownTime()\n\t\t\t&& ownTime() < saleEnd\n\t\t\t&& halvingTime > 0\n\t\t\t&& timeFlowQuantum > 0\n\t\t\t&& seqDuration > 0\n\t\t\t&& startPrices.length > 0;\n\t}\n\n\t/**\n\t * @dev Restricted access function to pause running sale in case of emergency\n\t *\n\t * @dev Pausing/resuming doesn't affect sale \"own time\" and allows to resume the\n\t *      sale process without \"loosing\" any items due to the time passed when paused\n\t *\n\t * @dev The sale is resumed using `resume()` function\n\t *\n\t * @dev Requires transaction sender to have `ROLE_PAUSE_MANAGER` role\n\t */\n\tfunction pause() public virtual {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_PAUSE_MANAGER), \"access denied\");\n\n\t\t// check if sale is not in the paused state already\n\t\trequire(pausedAt == 0, \"already paused\");\n\n\t\t// do the pause, save the paused timestamp\n\t\t// note for tests: never set time to zero in tests\n\t\tpausedAt = now32();\n\n\t\t// emit an event\n\t\temit Paused(msg.sender, now32());\n\t}\n\n\t/**\n\t * @dev Restricted access function to resume previously paused sale\n\t *\n\t * @dev Pausing/resuming doesn't affect sale \"own time\" and allows to resume the\n\t *      sale process without \"loosing\" any items due to the time passed when paused\n\t *\n\t * @dev Resuming the sale before it is scheduled to start doesn't have any effect\n\t *      on the sale flow, and doesn't delay the sale start\n\t *\n\t * @dev Resuming the sale which was paused before the scheduled start delays the sale,\n\t *      and moves scheduled sale start by the amount of time it was paused after the\n\t *      original scheduled start\n\t *\n\t * @dev The sale is paused using `pause()` function\n\t *\n\t * @dev Requires transaction sender to have `ROLE_PAUSE_MANAGER` role\n\t */\n\tfunction resume() public virtual {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_PAUSE_MANAGER), \"access denied\");\n\n\t\t// check if the sale is in a paused state\n\t\trequire(pausedAt != 0, \"already running\");\n\n\t\t// if sale has already started\n\t\tif(now32() > saleStart) {\n\t\t\t// update the cumulative sale pause duration, taking into account that\n\t\t\t// if sale was paused before its planned start, pause duration counts only from the start\n\t\t\t// note: we deliberately subtract `pausedAt` from the current time first\n\t\t\t// to fail fast if `pausedAt` is bigger than current time (this can never happen by design)\n\t\t\tpauseDuration += now32() - (pausedAt < saleStart? saleStart: pausedAt);\n\t\t}\n\n\t\t// emit an event first - to log old `pausedAt` value\n\t\temit Resumed(msg.sender, pausedAt, now32(), pauseDuration);\n\n\t\t// do the resume, erase the paused timestamp\n\t\tpausedAt = 0;\n\t}\n\n\t/**\n\t * @dev Restricted access function to update the sale beneficiary address, the address\n\t *      can be set, updated, or \"unset\" (deleted, set to zero)\n\t *\n\t * @dev Setting the address to non-zero value effectively activates funds withdrawal\n\t *      mechanism via the push pattern\n\t *\n\t * @dev Setting the address to zero value effectively deactivates funds withdrawal\n\t *      mechanism via the push pattern (pull mechanism can be used instead)\n\t */\n\tfunction setBeneficiary(address payable _beneficiary) public virtual {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \"access denied\");\n\n\t\t// update the beneficiary address\n\t\tbeneficiary = _beneficiary;\n\n\t\t// emit an event\n\t\temit BeneficiaryUpdated(msg.sender, _beneficiary);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw funds on the contract balance,\n\t *      sends funds back to transaction sender\n\t *\n\t * @dev Withdraws both ETH and sILV balances if `_ethOnly` is set to false,\n\t *      withdraws only ETH is `_ethOnly` is set to true\n\t *\n\t * @param _ethOnly a flag indicating whether to withdraw sILV or not\n\t */\n\tfunction withdraw(bool _ethOnly) public virtual {\n\t\t// delegate to `withdrawTo`\n\t\twithdrawTo(payable(msg.sender), _ethOnly);\n\t}\n\n\t/**\n\t * @dev Restricted access function to withdraw funds on the contract balance,\n\t *      sends funds to the address specified\n\t *\n\t * @dev Withdraws both ETH and sILV balances if `_ethOnly` is set to false,\n\t *      withdraws only ETH is `_ethOnly` is set to true\n\t *\n\t * @param _to an address to send funds to\n\t * @param _ethOnly a flag indicating whether to withdraw sILV or not\n\t */\n\tfunction withdrawTo(address payable _to, bool _ethOnly) public virtual {\n\t\t// check the access permission\n\t\trequire(isSenderInRole(ROLE_WITHDRAWAL_MANAGER), \"access denied\");\n\n\t\t// verify withdrawal address is set\n\t\trequire(_to != address(0), \"recipient not set\");\n\n\t\t// ETH value to send\n\t\tuint256 ethBalance = address(this).balance;\n\n\t\t// sILV value to send\n\t\tuint256 sIlvBalance = _ethOnly? 0: ERC20(sIlvContract).balanceOf(address(this));\n\n\t\t// verify there is a balance to send\n\t\trequire(ethBalance > 0 || sIlvBalance > 0, \"zero balance\");\n\n\t\t// if there is ETH to send\n\t\tif(ethBalance > 0) {\n\t\t\t// send the entire balance to the address specified\n\t\t\t_to.transfer(ethBalance);\n\t\t}\n\n\t\t// if there is sILV to send\n\t\tif(sIlvBalance > 0) {\n\t\t\t// send the entire balance to the address specified\n\t\t\tERC20(sIlvContract).transfer(_to, sIlvBalance);\n\t\t}\n\n\t\t// emit en event\n\t\temit Withdrawn(msg.sender, _to, ethBalance, sIlvBalance);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\n\t *      the tokens are rescued via `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transfer(_to, _value)`\n\t *\n\t * @dev Doesn't allow to rescue sILV tokens, use withdraw/withdrawTo instead\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transfer(_to, _value)`\n\t * @param _value value to transfer in `transfer(_to, _value)`\n\t */\n\tfunction rescueErc20(address _contract, address _to, uint256 _value) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// verify rescue manager is not trying to withdraw sILV:\n\t\t// we have a withdrawal manager to help with that\n\t\trequire(_contract != sIlvContract, \"sILV access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC20(_contract).safeTransfer(_to, _value);\n\t}\n\n\t/**\n\t * @notice Determines the dutch auction price value for a token in a given\n\t *      sequence `sequenceId`, given tier `tierId`, now (block.timestamp)\n\t *\n\t * @dev Adjusts current time for the sale pause duration `pauseDuration`, using\n\t *      own time `ownTime()`\n\t *\n\t * @dev Throws if `now` is outside the [saleStart, saleEnd + pauseDuration) bounds,\n\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\n\t *      or if the tier specified is invalid (no starting price is defined for it)\n\t *\n\t * @param sequenceId ID of the sequence token is sold in\n\t * @param tierId ID of the tier token belongs to (defines token rarity)\n\t * @return current price of the token specified\n\t */\n\tfunction tokenPriceNow(uint32 sequenceId, uint16 tierId) public view virtual returns (uint256) {\n\t\t// delegate to `tokenPriceAt` using adjusted current time as `t`\n\t\treturn tokenPriceAt(sequenceId, tierId, ownTime());\n\t}\n\n\t/**\n\t * @notice Determines the dutch auction price value for a token in a given\n\t *      sequence `sequenceId`, given tier `tierId`, at a given time `t` (own time)\n\t *\n\t * @dev Throws if `t` is outside the [saleStart, saleEnd) bounds,\n\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\n\t *      or if the tier specified is invalid (no starting price is defined for it)\n\t *\n\t * @param sequenceId ID of the sequence token is sold in\n\t * @param tierId ID of the tier token belongs to (defines token rarity)\n\t * @param t unix timestamp of interest, time to evaluate the price at (own time)\n\t * @return price of the token specified at some unix timestamp `t` (own time)\n\t */\n\tfunction tokenPriceAt(uint32 sequenceId, uint16 tierId, uint32 t) public view virtual returns (uint256) {\n\t\t// calculate sequence sale start\n\t\tuint32 seqStart = saleStart + sequenceId * seqOffset;\n\t\t// calculate sequence sale end\n\t\tuint32 seqEnd = seqStart + seqDuration;\n\n\t\t// verify `t` is in a reasonable bounds [saleStart, saleEnd)\n\t\trequire(saleStart <= t && t < saleEnd, \"invalid time\");\n\n\t\t// ensure `t` is in `[seqStart, seqEnd)` bounds; no price exists outside the bounds\n\t\trequire(seqStart <= t && t < seqEnd, \"invalid sequence\");\n\n\t\t// verify the initial price is set (initialized) for the tier specified\n\t\trequire(startPrices.length > tierId, \"invalid tier\");\n\n\t\t// convert `t` from \"absolute\" to \"relative\" (within a sequence)\n\t\tt -= seqStart;\n\n\t\t// apply the time flow quantum: make `t` multiple of quantum\n\t\tt /= timeFlowQuantum;\n\t\tt *= timeFlowQuantum;\n\n\t\t// calculate the price based on the derived params - delegate to `price`\n\t\treturn price(startPrices[tierId], halvingTime, t);\n\t}\n\n\t/**\n\t * @dev Calculates dutch auction price after the time of interest has passed since\n\t *      the auction has started\n\t *\n\t * @dev The price is assumed to drop exponentially, according to formula:\n\t *      p(t) = p0 * 2^(-t/t0)\n\t *      The price halves every t0 seconds passed from the start of the auction\n\t *\n\t * @dev Calculates with the precision p0 * 2^(-1/256), meaning the price updates\n\t *      every t0 / 256 seconds\n\t *      For example, if halving time is one hour, the price updates every 14 seconds\n\t *\n\t * @param p0 initial price (wei)\n\t * @param t0 price halving time (seconds)\n\t * @param t elapsed time (seconds)\n\t * @return price after `t` seconds passed, `p = p0 * 2^(-t/t0)`\n\t */\n\tfunction price(uint256 p0, uint256 t0, uint256 t) public pure virtual returns (uint256) {\n\t\t// perform very rough price estimation first by halving\n\t\t// the price as many times as many t0 intervals have passed\n\t\tuint256 p = p0 >> t / t0;\n\n\t\t// if price halves (decreases by 2 times) every t0 seconds passed,\n\t\t// than every t0 / 2 seconds passed it decreases by sqrt(2) times (2 ^ (1/2)),\n\t\t// every t0 / 2 seconds passed it decreases 2 ^ (1/4) times, and so on\n\n\t\t// we've prepared a small cheat sheet here with the pre-calculated values for\n\t\t// the roots of the degree of two 2 ^ (1 / 2 ^ n)\n\t\t// for the resulting function to be monotonically decreasing, it is required\n\t\t// that (2 ^ (1 / 2 ^ n)) ^ 2 <= 2 ^ (1 / 2 ^ (n - 1))\n\t\t// to emulate floating point values, we present them as nominator/denominator\n\t\t// roots of the degree of two nominators:\n\t\tuint56[8] memory sqrNominator = [\n\t\t\t1_414213562373095, // 2 ^ (1/2)\n\t\t\t1_189207115002721, // 2 ^ (1/4)\n\t\t\t1_090507732665257, // 2 ^ (1/8) *\n\t\t\t1_044273782427413, // 2 ^ (1/16) *\n\t\t\t1_021897148654116, // 2 ^ (1/32) *\n\t\t\t1_010889286051700, // 2 ^ (1/64)\n\t\t\t1_005429901112802, // 2 ^ (1/128) *\n\t\t\t1_002711275050202  // 2 ^ (1/256)\n\t\t];\n\t\t// roots of the degree of two denominator:\n\t\tuint56 sqrDenominator =\n\t\t\t1_000000000000000;\n\n\t\t// perform up to 8 iterations to increase the precision of the calculation\n\t\t// dividing the halving time `t0` by two on every step\n\t\tfor(uint8 i = 0; i < sqrNominator.length && t > 0 && t0 > 1; i++) {\n\t\t\t// determine the reminder of `t` which requires the precision increase\n\t\t\tt %= t0;\n\t\t\t// halve the `t0` for the next iteration step\n\t\t\tt0 /= 2;\n\t\t\t// if elapsed time `t` is big enough and is \"visible\" with `t0` precision\n\t\t\tif(t >= t0) {\n\t\t\t\t// decrease the price accordingly to the roots of the degree of two table\n\t\t\t\tp = p * sqrDenominator / sqrNominator[i];\n\t\t\t}\n\t\t\t// if elapsed time `t` is big enough and is \"visible\" with `2 * t0` precision\n\t\t\t// (this is possible sometimes due to rounding errors when halving `t0`)\n\t\t\tif(t >= 2 * t0) {\n\t\t\t\t// decrease the price again accordingly to the roots of the degree of two table\n\t\t\t\tp = p * sqrDenominator / sqrNominator[i];\n\t\t\t}\n\t\t}\n\n\t\t// return the result\n\t\treturn p;\n\t}\n\n\t/**\n\t * @notice Sells a plot of land (Land ERC721 token) from the sale to executor.\n\t *      Executor must supply the metadata for the land plot and a Merkle tree proof\n\t *      for the metadata supplied.\n\t *\n\t * @notice Mints the token bought immediately on L1 as part of the buy transaction\n\t *\n\t * @notice Metadata for all the plots is stored off-chain and is publicly available\n\t *      to buy plots and to generate Merkle proofs\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the plot data collection elements via `web3.utils.soliditySha3`, making sure\n\t *         the packing order and types are exactly as defined in `PlotData` struct\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed collection, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given plot data element the proof is constructed by hashing it (as in step 1),\n\t *         and querying the MerkleTree for a proof, providing the hashed plot data element as a leaf\n\t *\n\t * @dev Requires FEATURE_L1_SALE_ACTIVE feature to be enabled\n\t *\n\t * @dev Throws if current time is outside the [saleStart, saleEnd + pauseDuration) bounds,\n\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\n\t *      or if the tier specified is invalid (no starting price is defined for it)\n\t *\n\t * @dev See also: https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\n\t *\n\t * @param plotData plot data to buy\n\t * @param proof Merkle proof for the plot data supplied\n\t */\n\tfunction buyL1(PlotData memory plotData, bytes32[] memory proof) public virtual payable {\n\t\t// verify L1 sale is active\n\t\trequire(isFeatureEnabled(FEATURE_L1_SALE_ACTIVE), \"L1 sale disabled\");\n\n\t\t// execute all the validations, process payment, construct the land plot\n\t\t(LandLib.PlotStore memory plot, uint256 pEth, uint256 pIlv) = _buy(plotData, proof);\n\n\t\t// mint the token in L1 with metadata - delegate to `mintWithMetadata`\n\t\tLandERC721Metadata(targetNftContract).mintWithMetadata(msg.sender, plotData.tokenId, plot);\n\n\t\t// emit an event\n\t\temit PlotBoughtL1(msg.sender, plotData.tokenId, plotData.sequenceId, plot, pEth, pIlv);\n\t}\n\n\t/**\n\t * @notice Sells a plot of land (Land ERC721 token) from the sale to executor.\n\t *      Executor must supply the metadata for the land plot and a Merkle tree proof\n\t *      for the metadata supplied.\n\t *\n\t * @notice Doesn't mint the token bought immediately on L1 as part of the buy transaction,\n\t *      only `PlotBoughtL2` event is emitted instead, which is picked by off-chain process\n\t *      and then minted in L2\n\t *\n\t * @notice Metadata for all the plots is stored off-chain and is publicly available\n\t *      to buy plots and to generate Merkle proofs\n\t *\n\t * @dev Merkle tree and proof can be constructed using the `web3-utils`, `merkletreejs`,\n\t *      and `keccak256` npm packages:\n\t *      1. Hash the plot data collection elements via `web3.utils.soliditySha3`, making sure\n\t *         the packing order and types are exactly as defined in `PlotData` struct\n\t *      2. Create a sorted MerkleTree (`merkletreejs`) from the hashed collection, use `keccak256`\n\t *         from the `keccak256` npm package as a hashing function, do not hash leaves\n\t *         (already hashed in step 1); Ex. MerkleTree options: {hashLeaves: false, sortPairs: true}\n\t *      3. For any given plot data element the proof is constructed by hashing it (as in step 1),\n\t *         and querying the MerkleTree for a proof, providing the hashed plot data element as a leaf\n\t *\n\t * @dev Requires FEATURE_L2_SALE_ACTIVE feature to be enabled\n\t *\n\t * @dev Throws if current time is outside the [saleStart, saleEnd + pauseDuration) bounds,\n\t *      or if it is outside the sequence bounds (sequence lasts for `seqDuration`),\n\t *      or if the tier specified is invalid (no starting price is defined for it)\n\t *\n\t * @dev See also: https://docs.openzeppelin.com/contracts/4.x/api/utils#MerkleProof\n\t *\n\t * @param plotData plot data to buy\n\t * @param proof Merkle proof for the plot data supplied\n\t */\n\tfunction buyL2(PlotData memory plotData, bytes32[] memory proof) public virtual payable {\n\t\t// verify L2 sale is active\n\t\trequire(isFeatureEnabled(FEATURE_L2_SALE_ACTIVE), \"L2 sale disabled\");\n\n\t\t// buying in L2 requires EOA buyer, otherwise we cannot guarantee L2 mint:\n\t\t// an address which doesn't have private key cannot be registered with IMX\n\t\t// note: should be used with care, see https://github.com/ethereum/solidity/issues/683\n\t\trequire(msg.sender == tx.origin, \"L2 sale requires EOA\");\n\n\t\t// execute all the validations, process payment, construct the land plot\n\t\t(LandLib.PlotStore memory plot, uint256 pEth, uint256 pIlv) = _buy(plotData, proof);\n\n\t\t// note: token is not minted in L1, it will be picked by the off-chain process and minted in L2\n\n\t\t// emit an event\n\t\temit PlotBoughtL2(msg.sender, plotData.tokenId, plotData.sequenceId, plot, plot.pack(), pEth, pIlv);\n\t}\n\n\t/**\n\t * @dev Auxiliary function used in both `buyL1` and `buyL2` functions to\n\t *      - execute all the validations required,\n\t *      - process payment,\n\t *      - generate random seed to derive internal land structure (landmark and sites), and\n\t *      - construct the `LandLib.PlotStore` data structure representing land plot bought\n\t *\n\t * @dev See `buyL1` and `buyL2` functions for more details\n\t */\n\tfunction _buy(\n\t\tPlotData memory plotData,\n\t\tbytes32[] memory proof\n\t) internal virtual returns (\n\t\tLandLib.PlotStore memory plot,\n\t\tuint256 pEth,\n\t\tuint256 pIlv\n\t) {\n\t\t// check if sale is active (and initialized)\n\t\trequire(isActive(), \"inactive sale\");\n\n\t\t// make sure plot data Merkle root was set (sale has something on sale)\n\t\trequire(root != 0x00, \"empty sale\");\n\n\t\t// verify the plot supplied is a valid/registered plot\n\t\trequire(isPlotValid(plotData, proof), \"invalid plot\");\n\n\t\t// verify if token is not yet minted and mark it as minted\n\t\t_markAsMinted(plotData.tokenId);\n\n\t\t// process the payment, save the ETH/sILV lot prices\n\t\t// a note on reentrancy: `_processPayment` may execute a fallback function on the smart contract buyer,\n\t\t// which would be the last execution statement inside `_processPayment`; this execution is reentrancy safe\n\t\t// not only because 2,300 transfer function is used, but primarily because all the \"give\" logic is executed after\n\t\t// external call, while the \"withhold\" logic is executed before the external call\n\t\t(pEth, pIlv) = _processPayment(plotData.sequenceId, plotData.tierId);\n\n\t\t// generate the random seed to derive internal land structure (landmark and sites)\n\t\t// hash the token ID, block timestamp and tx executor address to get a seed\n\t\tuint256 seed = uint256(keccak256(abi.encodePacked(plotData.tokenId, now32(), msg.sender)));\n\n\t\t// allocate the land plot metadata in memory\n\t\tplot = LandLib.PlotStore({\n\t\t\tversion: 1,\n\t\t\tregionId: plotData.regionId,\n\t\t\tx: plotData.x,\n\t\t\ty: plotData.y,\n\t\t\ttierId: plotData.tierId,\n\t\t\tsize: plotData.size,\n\t\t\t// use generated seed to derive the Landmark Type ID, seed is considered \"used\" after that\n\t\t\tlandmarkTypeId: LandLib.getLandmark(seed, plotData.tierId),\n\t\t\telementSites: 3 * plotData.tierId,\n\t\t\tfuelSites: plotData.tierId < 2? plotData.tierId: 3 * (plotData.tierId - 1),\n\t\t\t// store low 160 bits of the \"used\" seed in the plot structure\n\t\t\tseed: uint160(seed)\n\t\t});\n\n\t\t// return the results as a tuple\n\t\treturn (plot, pEth, pIlv);\n\t}\n\n\t/**\n\t * @dev Verifies if token is minted and marks it as minted\n\t *\n\t * @dev Throws if token is already minted\n\t *\n\t * @param tokenId token ID to check and mark as minted\n\t */\n\tfunction _markAsMinted(uint256 tokenId) internal virtual {\n\t\t// calculate bit location to set in `mintedTokens`\n\t\t// slot index\n\t\tuint256 i = tokenId / 256;\n\t\t// bit location within the slot\n\t\tuint256 j = tokenId % 256;\n\n\t\t// verify bit `j` at slot `i` is not set\n\t\trequire(mintedTokens[i] >> j & 0x1 == 0, \"already minted\");\n\t\t// set bit `j` at slot index `i`\n\t\tmintedTokens[i] |= 0x1 << j;\n\t}\n\n\t/**\n\t * @dev Verifies if token is minted\n\t *\n\t * @param tokenId token ID to check if it's minted\n\t */\n\tfunction exists(uint256 tokenId) public view returns(bool) {\n\t\t// calculate bit location to check in `mintedTokens`\n\t\t// slot index: i = tokenId / 256\n\t\t// bit location within the slot: j = tokenId % 256\n\n\t\t// verify if bit `j` at slot `i` is set\n\t\treturn mintedTokens[tokenId / 256] >> tokenId % 256 & 0x1 == 1;\n\t}\n\n\t/**\n\t * @dev Charges tx executor in ETH/sILV, based on if ETH is supplied in the tx or not:\n\t *      - if ETH is supplied, charges ETH only (throws if value supplied is not enough)\n\t *      - if ETH is not supplied, charges sILV only (throws if sILV transfer fails)\n\t *\n\t * @dev Sends the change (for ETH payment - if any) back to transaction executor\n\t *\n\t * @dev Internal use only, throws on any payment failure\n\t *\n\t * @param sequenceId ID of the sequence token is sold in\n\t * @param tierId ID of the tier token belongs to (defines token rarity)\n\t */\n\tfunction _processPayment(uint32 sequenceId, uint16 tierId) internal virtual returns (uint256 pEth, uint256 pIlv) {\n\t\t// determine current token price\n\t\tpEth = tokenPriceNow(sequenceId, tierId);\n\n\t\t// current land sale version doesn't support free tiers (ID: 0)\n\t\trequire(pEth != 0, \"unsupported tier\");\n\n\t\t// if ETH is not supplied, try to process sILV payment\n\t\tif(msg.value == 0) {\n\t\t\t// convert price `p` to ILV/sILV\n\t\t\tpIlv = LandSalePriceOracle(priceOracle).ethToIlv(pEth);\n\n\t\t\t// LandSaleOracle implementation guarantees the price to have meaningful value,\n\t\t\t// we still check \"close to zero\" price case to be extra safe\n\t\t\trequire(pIlv > 1_000, \"price conversion error\");\n\n\t\t\t// verify sender sILV balance and allowance to improve error messaging\n\t\t\t// note: `transferFrom` would fail anyway, but sILV deployed into the mainnet\n\t\t\t//       would just fail with \"arithmetic underflow\" without any hint for the cause\n\t\t\trequire(ERC20(sIlvContract).balanceOf(msg.sender) >= pIlv, \"not enough funds available\");\n\t\t\trequire(ERC20(sIlvContract).allowance(msg.sender, address(this)) >= pIlv, \"not enough funds supplied\");\n\n\t\t\t// if beneficiary address is set, transfer the funds directly to the beneficiary\n\t\t\t// otherwise, transfer the funds to the sale contract for the future pull withdrawal\n\t\t\t// note: sILV.transferFrom always throws on failure and never returns `false`, however\n\t\t\t//       to keep this code \"copy-paste safe\" we do require it to return `true` explicitly\n\t\t\trequire(\n\t\t\t\tERC20(sIlvContract).transferFrom(msg.sender, beneficiary != address(0)? beneficiary: address(this), pIlv),\n\t\t\t\t\"ERC20 transfer failed\"\n\t\t\t);\n\n\t\t\t// no need for the change processing here since we're taking the amount ourselves\n\n\t\t\t// return ETH price and sILV price actually charged\n\t\t\treturn (pEth, pIlv);\n\t\t}\n\n\t\t// process ETH payment otherwise\n\n\t\t// ensure amount of ETH send\n\t\trequire(msg.value >= pEth, \"not enough ETH\");\n\n\t\t// if beneficiary address is set\n\t\tif(beneficiary != address(0)) {\n\t\t\t// transfer the funds directly to the beneficiary\n\t\t\t// note: beneficiary cannot be a smart contract with complex fallback function\n\t\t\t//       by design, therefore we're using the 2,300 gas transfer\n\t\t\tbeneficiary.transfer(pEth);\n\t\t}\n\t\t// if beneficiary address is not set, funds remain on\n\t\t// the sale contract address for the future pull withdrawal\n\n\t\t// if there is any change sent in the transaction\n\t\t// (most of the cases there will be a change since this is a dutch auction)\n\t\tif(msg.value > pEth) {\n\t\t\t// transfer the change back to the transaction executor (buyer)\n\t\t\t// note: calling the sale contract by other smart contracts with complex fallback functions\n\t\t\t//       is not supported by design, therefore we're using the 2,300 gas transfer\n\t\t\tpayable(msg.sender).transfer(msg.value - pEth);\n\t\t}\n\n\t\t// return the ETH price charged\n\t\treturn (pEth, 0);\n\t}\n\n\t/**\n\t * @notice Current time adjusted to count for the total duration sale was on pause\n\t *\n\t * @dev If sale operates in a normal way, without emergency pausing involved, this\n\t *      is always equal to the current time;\n\t *      if sale is paused for some period of time, this duration is subtracted, the\n\t *      sale \"slows down\", and behaves like if it had a delayed start\n\t *\n\t * @return sale own time, current time adjusted by `pauseDuration`\n\t */\n\tfunction ownTime() public view virtual returns (uint32) {\n\t\t// subtract total pause duration from the current time (if any) and return\n\t\treturn now32() - pauseDuration;\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now32() public view virtual returns (uint32) {\n\t\t// return current block timestamp\n\t\treturn uint32(block.timestamp);\n\t}\n}\n"
    },
    "contracts/interfaces/ERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./ERC165Spec.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev Solidity issue #3412: The ERC721 interfaces include explicit mutability guarantees for each function.\n *      Mutability guarantees are, in order weak to strong: payable, implicit nonpayable, view, and pure.\n *      Implementation MUST meet the mutability guarantee in this interface and MAY meet a stronger guarantee.\n *      For example, a payable function in this interface may be implemented as nonpayable\n *      (no state mutability specified) in implementing contract.\n *      It is expected a later Solidity release will allow stricter contract to inherit from this interface,\n *      but current workaround is that we edit this interface to add stricter mutability before inheriting:\n *      we have removed all \"payable\" modifiers.\n *\n * @dev The ERC-165 identifier for this interface is 0x80ac58cd.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721 is ERC165 {\n\t/// @dev This emits when ownership of any NFT changes by any mechanism.\n\t///  This event emits when NFTs are created (`from` == 0) and destroyed\n\t///  (`to` == 0). Exception: during contract creation, any number of NFTs\n\t///  may be created and assigned without emitting Transfer. At the time of\n\t///  any transfer, the approved address for that NFT (if any) is reset to none.\n\tevent Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\n\n\t/// @dev This emits when the approved address for an NFT is changed or\n\t///  reaffirmed. The zero address indicates there is no approved address.\n\t///  When a Transfer event emits, this also indicates that the approved\n\t///  address for that NFT (if any) is reset to none.\n\tevent Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\n\n\t/// @dev This emits when an operator is enabled or disabled for an owner.\n\t///  The operator can manage all NFTs of the owner.\n\tevent ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\n\n\t/// @notice Count all NFTs assigned to an owner\n\t/// @dev NFTs assigned to the zero address are considered invalid, and this\n\t///  function throws for queries about the zero address.\n\t/// @param _owner An address for whom to query the balance\n\t/// @return The number of NFTs owned by `_owner`, possibly zero\n\tfunction balanceOf(address _owner) external view returns (uint256);\n\n\t/// @notice Find the owner of an NFT\n\t/// @dev NFTs assigned to zero address are considered invalid, and queries\n\t///  about them do throw.\n\t/// @param _tokenId The identifier for an NFT\n\t/// @return The address of the owner of the NFT\n\tfunction ownerOf(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT. When transfer is complete, this function\n\t///  checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t///  `onERC721Received` on `_to` and throws if the return value is not\n\t///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\t/// @param _data Additional data with no specified format, sent in call to `_to`\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external /*payable*/;\n\n\t/// @notice Transfers the ownership of an NFT from one address to another address\n\t/// @dev This works identically to the other function with an extra data parameter,\n\t///  except this function just sets data to \"\".\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction safeTransferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\n\t///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\n\t///  THEY MAY BE PERMANENTLY LOST\n\t/// @dev Throws unless `msg.sender` is the current owner, an authorized\n\t///  operator, or the approved address for this NFT. Throws if `_from` is\n\t///  not the current owner. Throws if `_to` is the zero address. Throws if\n\t///  `_tokenId` is not a valid NFT.\n\t/// @param _from The current owner of the NFT\n\t/// @param _to The new owner\n\t/// @param _tokenId The NFT to transfer\n\tfunction transferFrom(address _from, address _to, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Change or reaffirm the approved address for an NFT\n\t/// @dev The zero address indicates there is no approved address.\n\t///  Throws unless `msg.sender` is the current NFT owner, or an authorized\n\t///  operator of the current owner.\n\t/// @param _approved The new approved NFT controller\n\t/// @param _tokenId The NFT to approve\n\tfunction approve(address _approved, uint256 _tokenId) external /*payable*/;\n\n\t/// @notice Enable or disable approval for a third party (\"operator\") to manage\n\t///  all of `msg.sender`'s assets\n\t/// @dev Emits the ApprovalForAll event. The contract MUST allow\n\t///  multiple operators per owner.\n\t/// @param _operator Address to add to the set of authorized operators\n\t/// @param _approved True if the operator is approved, false to revoke approval\n\tfunction setApprovalForAll(address _operator, bool _approved) external;\n\n\t/// @notice Get the approved address for a single NFT\n\t/// @dev Throws if `_tokenId` is not a valid NFT.\n\t/// @param _tokenId The NFT to find the approved address for\n\t/// @return The approved address for this NFT, or the zero address if there is none\n\tfunction getApproved(uint256 _tokenId) external view returns (address);\n\n\t/// @notice Query if an address is an authorized operator for another address\n\t/// @param _owner The address that owns the NFTs\n\t/// @param _operator The address that acts on behalf of the owner\n\t/// @return True if `_operator` is an approved operator for `_owner`, false otherwise\n\tfunction isApprovedForAll(address _owner, address _operator) external view returns (bool);\n}\n\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\ninterface ERC721TokenReceiver {\n\t/// @notice Handle the receipt of an NFT\n\t/// @dev The ERC721 smart contract calls this function on the recipient\n\t///  after a `transfer`. This function MAY throw to revert and reject the\n\t///  transfer. Return of other than the magic value MUST result in the\n\t///  transaction being reverted.\n\t///  Note: the contract address is always the message sender.\n\t/// @param _operator The address which called `safeTransferFrom` function\n\t/// @param _from The address which previously owned the token\n\t/// @param _tokenId The NFT identifier which is being transferred\n\t/// @param _data Additional data with no specified format\n\t/// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n\t///  unless throwing\n\tfunction onERC721Received(\n\t\taddress _operator,\n\t\taddress _from,\n\t\tuint256 _tokenId,\n\t\tbytes calldata _data\n\t) external returns (bytes4);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x5b5e139f.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Metadata is ERC721 {\n\t/// @notice A descriptive name for a collection of NFTs in this contract\n\tfunction name() external view returns (string memory _name);\n\n\t/// @notice An abbreviated name for NFTs in this contract\n\tfunction symbol() external view returns (string memory _symbol);\n\n\t/// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\n\t/// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\n\t///  3986. The URI may point to a JSON file that conforms to the \"ERC721\n\t///  Metadata JSON Schema\".\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n *\n * @notice See https://eips.ethereum.org/EIPS/eip-721\n *\n * @dev The ERC-165 identifier for this interface is 0x780e9d63.\n *\n * @author William Entriken, Dieter Shirley, Jacob Evans, Nastassia Sachs\n */\ninterface ERC721Enumerable is ERC721 {\n\t/// @notice Count NFTs tracked by this contract\n\t/// @return A count of valid NFTs tracked by this contract, where each one of\n\t///  them has an assigned and queryable owner not equal to the zero address\n\tfunction totalSupply() external view returns (uint256);\n\n\t/// @notice Enumerate valid NFTs\n\t/// @dev Throws if `_index` >= `totalSupply()`.\n\t/// @param _index A counter less than `totalSupply()`\n\t/// @return The token identifier for the `_index`th NFT,\n\t///  (sort order not specified)\n\tfunction tokenByIndex(uint256 _index) external view returns (uint256);\n\n\t/// @notice Enumerate NFTs assigned to an owner\n\t/// @dev Throws if `_index` >= `balanceOf(_owner)` or if\n\t///  `_owner` is the zero address, representing invalid NFTs.\n\t/// @param _owner An address where we are interested in NFTs owned by them\n\t/// @param _index A counter less than `balanceOf(_owner)`\n\t/// @return The token identifier for the `_index`th NFT assigned to `_owner`,\n\t///   (sort order not specified)\n\tfunction tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\n}\n"
    },
    "contracts/interfaces/LandERC721Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/LandLib.sol\";\n\n/**\n * @title Land ERC721 Metadata\n *\n * @notice Defines metadata-related capabilities for LandERC721 token.\n *      This interface should be treated as a definition of what metadata is for LandERC721,\n *      and what operations are defined/allowed for it.\n *\n * @author Basil Gorin\n */\ninterface LandERC721Metadata {\n\t/**\n\t * @notice Presents token metadata in a well readable form,\n\t *      with the Internal Land Structure included, as a `PlotView` struct\n\t *\n\t * @notice Reconstructs the internal land structure of the plot based on the stored\n\t *      Tier ID, Plot Size, Generator Version, and Seed\n\t *\n\t * @param _tokenId token ID to query metadata view for\n\t * @return token metadata as a `PlotView` struct\n\t */\n\tfunction viewMetadata(uint256 _tokenId) external view returns (LandLib.PlotView memory);\n\n\t/**\n\t * @notice Presents token metadata \"as is\", without the Internal Land Structure included,\n\t *      as a `PlotStore` struct;\n\t *\n\t * @notice Doesn't reconstruct the internal land structure of the plot, allowing to\n\t *      access Generator Version, and Seed fields \"as is\"\n\t *\n\t * @param _tokenId token ID to query on-chain metadata for\n\t * @return token metadata as a `PlotStore` struct\n\t */\n\tfunction getMetadata(uint256 _tokenId) external view returns (LandLib.PlotStore memory);\n\n\t/**\n\t * @notice Verifies if token has its metadata set on-chain; for the tokens\n\t *      in existence metadata is immutable, it can be set once, and not updated\n\t *\n\t * @dev If `exists(_tokenId) && hasMetadata(_tokenId)` is true, `setMetadata`\n\t *      for such a `_tokenId` will always throw\n\t *\n\t * @param _tokenId token ID to check metadata existence for\n\t * @return true if token ID specified has metadata associated with it\n\t */\n\tfunction hasMetadata(uint256 _tokenId) external view returns (bool);\n\n\t/**\n\t * @dev Sets/updates token metadata on-chain; same metadata struct can be then\n\t *      read back using `getMetadata()` function, or it can be converted to\n\t *      `PlotView` using `viewMetadata()` function\n\t *\n\t * @dev The metadata supplied is validated to satisfy (regionId, x, y) uniqueness;\n\t *      non-intersection of the sites coordinates within a plot is guaranteed by the\n\t *      internal land structure generator algorithm embedded into the `viewMetadata()`\n\t *\n\t * @dev Metadata for non-existing tokens can be set and updated unlimited\n\t *      amount of times without any restrictions (except the constraints above)\n\t * @dev Metadata for an existing token can only be set, it cannot be updated\n\t *      (`setMetadata` will throw if metadata already exists)\n\t *\n\t * @param _tokenId token ID to set/updated the metadata for\n\t * @param _plot token metadata to be set for the token ID\n\t */\n\tfunction setMetadata(uint256 _tokenId, LandLib.PlotStore memory _plot) external;\n\n\t/**\n\t * @dev Removes token metadata\n\t *\n\t * @param _tokenId token ID to remove metadata for\n\t */\n\tfunction removeMetadata(uint256 _tokenId) external;\n\n\t/**\n\t * @dev Mints the token and assigns the metadata supplied\n\t *\n\t * @dev Creates new token with the token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Consider minting with `safeMint` (and setting metadata before),\n\t *      for the \"safe mint\" like behavior\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint and set metadata for\n\t * @param _plot token metadata to be set for the token ID\n\t */\n\tfunction mintWithMetadata(address _to, uint256 _tokenId, LandLib.PlotStore memory _plot) external;\n}\n\n/**\n * @title Land Descriptor\n *\n * @notice Auxiliary module which is dynamically injected into LandERC721 contract\n *      to override the default ERC721.tokenURI behaviour\n *\n * @notice This can be used, for example, to enable on-chain generation of the SVG\n *      image representation of the land plot, encoding it into base64 string, and\n *      using it instead of token URI pointing to some off-chain sotrage location\n *\n * @dev Can be dynamically injected into LandERC721 at any time, can be dynamically detached\n *      from the LandERC721 once attached (injected)\n *\n * @author Pedro Bergamini, Basil Gorin\n */\ninterface LandDescriptor {\n\t/**\n\t * @notice Creates SVG image with the land plot metadata painted on it,\n\t *      encodes the generated SVG into base64 URI string\n\t *\n\t * @param _tokenId token ID of the land plot to generate SVG for\n\t */\n\tfunction tokenURI(uint256 _tokenId) external view returns (string memory);\n}\n"
    },
    "contracts/interfaces/PriceOracleSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Pair Price Oracle, a.k.a. Pair Oracle\n *\n * @notice Generic interface used to consult on the Uniswap-like token pairs conversion prices;\n *      one pair oracle is used to consult on the exchange rate within a single token pair\n *\n * @notice See also: https://docs.uniswap.org/protocol/V2/guides/smart-contract-integration/building-an-oracle\n *\n * @author Basil Gorin\n */\ninterface PairOracle {\n\t/**\n\t * @notice Updates the oracle with the price values if required, for example\n\t *      the cumulative price at the start and end of a period, etc.\n\t *\n\t * @dev This function is part of the oracle maintenance flow\n\t */\n\tfunction update() external;\n\n\t/**\n\t * @notice For a pair of tokens A/B (sell/buy), consults on the amount of token B to be\n\t *      bought if the specified amount of token A to be sold\n\t *\n\t * @dev This function is part of the oracle usage flow\n\t *\n\t * @param token token A (token to sell) address\n\t * @param amountIn amount of token A to sell\n\t * @return amountOut amount of token B to be bought\n\t */\n\tfunction consult(address token, uint256 amountIn) external view returns (uint256 amountOut);\n}\n\n/**\n * @title Price Oracle Registry\n *\n * @notice To make pair oracles more convenient to use, a more generic Oracle Registry\n *        interface is introduced: it stores the addresses of pair price oracles and allows\n *        searching/querying for them\n *\n * @author Basil Gorin\n */\ninterface PriceOracleRegistry {\n\t/**\n\t * @notice Searches for the Pair Price Oracle for A/B (sell/buy) token pair\n\t *\n\t * @param tokenA token A (token to sell) address\n\t * @param tokenB token B (token to buy) address\n\t * @return pairOracle pair price oracle address for A/B token pair\n\t */\n\tfunction getPriceOracle(address tokenA, address tokenB) external view returns (address pairOracle);\n}\n\n/**\n * @title Land Sale Price Oracle\n *\n * @notice Supports the Land Sale with the ETH/ILV conversion required,\n *       marker interface is required to support ERC165 lookups\n *\n * @author Basil Gorin\n */\ninterface LandSalePriceOracle {\n\t/**\n\t * @notice Powers the ETH/ILV Land token price conversion, used when\n\t *      selling the land for sILV to determine how much sILV to accept\n\t *      instead of the nominated ETH price\n\t *\n\t * @notice Note that sILV price is considered to be equal to ILV price\n\t *\n\t * @dev Implementation must guarantee not to return zero, absurdly small\n\t *      or big values, it must guarantee the price is up to date with some\n\t *      reasonable update interval threshold\n\t *\n\t * @param ethOut amount of ETH sale contract is expecting to get\n\t * @return ilvIn amount of sILV sale contract should accept instead\n\t */\n\tfunction ethToIlv(uint256 ethOut) external returns (uint256 ilvIn);\n}\n"
    },
    "contracts/lib/LandLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Land Library\n *\n * @notice A library defining data structures related to land plots (used in Land ERC721 token),\n *      and functions transforming these structures between view and internal (packed) representations,\n *      in both directions.\n *\n * @notice Due to some limitations Solidity has (ex.: allocating array of structures in storage),\n *      and due to the specific nature of internal land structure\n *      (landmark and resource sites data is deterministically derived from a pseudo random seed),\n *      it is convenient to separate data structures used to store metadata on-chain (store),\n *      and data structures used to present metadata via smart contract ABI (view)\n *\n * @notice Introduces helper functions to detect and deal with the resource site collisions\n *\n * @author Basil Gorin\n */\nlibrary LandLib {\n\t/**\n\t * @title Resource Site View\n\t *\n\t * @notice Resource Site, bound to a coordinates (x, y) within the land plot\n\t *\n\t * @notice Resources can be of two major types, each type having three subtypes:\n\t *      - Element (Carbon, Silicon, Hydrogen), or\n\t *      - Fuel (Crypton, Hyperion, Solon)\n\t *\n\t * @dev View only structure, used in public API/ABI, not used in on-chain storage\n\t */\n\tstruct Site {\n\t\t/**\n\t\t * @dev Site type:\n\t\t *        1) Carbon (element),\n\t\t *        2) Silicon (element),\n\t\t *        3) Hydrogen (element),\n\t\t *        4) Crypton (fuel),\n\t\t *        5) Hyperion (fuel),\n\t\t *        6) Solon (fuel)\n\t\t */\n\t\tuint8 typeId;\n\n\t\t/**\n\t\t * @dev x-coordinate within a plot\n\t\t */\n\t\tuint16 x;\n\n\t\t/**\n\t\t * @dev y-coordinate within a plot\n\t\t */\n\t\tuint16 y;\n\t}\n\n\t/**\n\t * @title Land Plot View\n\t *\n\t * @notice Land Plot, bound to a coordinates (x, y) within the region,\n\t *      with a rarity defined by the tier ID, sites, and (optionally)\n\t *      a landmark, positioned on the internal coordinate grid of the\n\t *      specified size within a plot.\n\t *\n\t * @notice Land plot coordinates and rarity are predefined (stored off-chain).\n\t *      Number of sites (and landmarks - 0/1) is defined by the land rarity.\n\t *      Positions of sites, types of sites/landmark are randomized and determined\n\t *      upon land plot creation.\n\t *\n\t * @dev View only structure, used in public API/ABI, not used in on-chain storage\n\t */\n\tstruct PlotView {\n\t\t/**\n\t\t * @dev Region ID defines the region on the map in IZ:\n\t\t *        1) Abyssal Basin\n\t\t *        2) Brightland Steppes\n\t\t *        3) Shardbluff Labyrinth\n\t\t *        4) Crimson Waste\n\t\t *        5) Halcyon Sea\n\t\t *        6) Taiga Boreal\n\t\t *        7) Crystal Shores\n\t\t */\n\t\tuint8 regionId;\n\n\t\t/**\n\t\t * @dev x-coordinate within the region\n\t\t */\n\t\tuint16 x;\n\n\t\t/**\n\t\t * @dev y-coordinate within the region\n\t\t */\n\t\tuint16 y;\n\n\t\t/**\n\t\t * @dev Tier ID defines land rarity and number of sites within the plot\n\t\t */\n\t\tuint8 tierId;\n\n\t\t/**\n\t\t * @dev Plot size, limits the (x, y) coordinates for the sites\n\t\t */\n\t\tuint16 size;\n\n\t\t/**\n\t\t * @dev Landmark Type ID:\n\t\t *        0) no Landmark\n\t\t *        1) Carbon Landmark,\n\t\t *        2) Silicon Landmark,\n\t\t *        3) Hydrogen Landmark (Eternal Spring),\n\t\t *        4) Crypton Landmark,\n\t\t *        5) Hyperion Landmark,\n\t\t *        6) Solon Landmark (Fallen Star),\n\t\t *        7) Arena\n\t\t *\n\t\t * @dev Landmark is always positioned in the center of internal grid\n\t\t */\n\t\tuint8 landmarkTypeId;\n\n\t\t/**\n\t\t * @dev Number of Element Sites (Carbon, Silicon, or Hydrogen) this plot contains,\n\t\t *      matches the number of element sites in sites[] array\n\t\t */\n\t\tuint8 elementSites;\n\n\t\t/**\n\t\t * @dev Number of Fuel Sites (Crypton, Hyperion, or Solon) this plot contains,\n\t\t *      matches the number of fuel sites in sites[] array\n\t\t */\n\t\tuint8 fuelSites;\n\n\t\t/**\n\t\t * @dev Element/fuel sites within the plot\n\t\t */\n\t\tSite[] sites;\n\t}\n\n\t/**\n\t * @title Land Plot Store\n\t *\n\t * @notice Land Plot data structure as it is stored on-chain\n\t *\n\t * @notice Contains the data required to generate `PlotView` structure:\n\t *      - regionId, x, y, tierId, size, landmarkTypeId, elementSites, and fuelSites are copied as is\n\t *      - version and seed are used to derive array of sites (together with elementSites, and fuelSites)\n\t *\n\t * @dev On-chain optimized structure, has limited usage in public API/ABI\n\t */\n\tstruct PlotStore {\n\t\t/**\n\t\t * @dev Generator Version, reserved for the future use in order to tweak the\n\t\t *      behavior of the internal land structure algorithm\n\t\t */\n\t\tuint8 version;\n\n\t\t/**\n\t\t * @dev Region ID defines the region on the map in IZ:\n\t\t *        1) Abyssal Basin\n\t\t *        2) Brightland Steppes\n\t\t *        3) Shardbluff Labyrinth\n\t\t *        4) Crimson Waste\n\t\t *        5) Halcyon Sea\n\t\t *        6) Taiga Boreal\n\t\t *        7) Crystal Shores\n\t\t */\n\t\tuint8 regionId;\n\n\t\t/**\n\t\t * @dev x-coordinate within the region\n\t\t */\n\t\tuint16 x;\n\n\t\t/**\n\t\t * @dev y-coordinate within the region\n\t\t */\n\t\tuint16 y;\n\n\t\t/**\n\t\t * @dev Tier ID defines land rarity and number of sites within the plot\n\t\t */\n\t\tuint8 tierId;\n\n\t\t/**\n\t\t * @dev Plot Size, limits the (x, y) coordinates for the sites\n\t\t */\n\t\tuint16 size;\n\n\t\t/**\n\t\t * @dev Landmark Type ID:\n\t\t *        0) no Landmark\n\t\t *        1) Carbon Landmark,\n\t\t *        2) Silicon Landmark,\n\t\t *        3) Hydrogen Landmark (Eternal Spring),\n\t\t *        4) Crypton Landmark,\n\t\t *        5) Hyperion Landmark,\n\t\t *        6) Solon Landmark (Fallen Star),\n\t\t *        7) Arena\n\t\t *\n\t\t * @dev Landmark is always positioned in the center of internal grid\n\t\t */\n\t\tuint8 landmarkTypeId;\n\n\t\t/**\n\t\t * @dev Number of Element Sites (Carbon, Silicon, or Hydrogen) this plot contains\n\t\t */\n\t\tuint8 elementSites;\n\n\t\t/**\n\t\t * @dev Number of Fuel Sites (Crypton, Hyperion, or Solon) this plot contains\n\t\t */\n\t\tuint8 fuelSites;\n\n\t\t/**\n\t\t * @dev Pseudo-random Seed to generate Internal Land Structure,\n\t\t *      should be treated as already used to derive Landmark Type ID\n\t\t */\n\t\tuint160 seed;\n\t}\n\n\t/**\n\t * @dev Tightly packs `PlotStore` data struct into uint256 representation\n\t *\n\t * @param store `PlotStore` data struct to pack\n\t * @return packed `PlotStore` data struct packed into uint256\n\t */\n\tfunction pack(PlotStore memory store) internal pure returns (uint256 packed) {\n\t\treturn uint256(store.version) << 248\n\t\t\t| uint248(store.regionId) << 240\n\t\t\t| uint240(store.x) << 224\n\t\t\t| uint224(store.y) << 208\n\t\t\t| uint208(store.tierId) << 200\n\t\t\t| uint200(store.size) << 184\n\t\t\t| uint184(store.landmarkTypeId) << 176\n\t\t\t| uint176(store.elementSites) << 168\n\t\t\t| uint168(store.fuelSites) << 160\n\t\t\t| uint160(store.seed);\n\t}\n\n\t/**\n\t * @dev Unpacks `PlotStore` data struct from uint256 representation\n\t *\n\t * @param packed uint256 packed `PlotStore` data struct\n\t * @return store unpacked `PlotStore` data struct\n\t */\n\tfunction unpack(uint256 packed) internal pure returns (PlotStore memory store) {\n\t\treturn PlotStore({\n\t\t\tversion:        uint8(packed >> 248),\n\t\t\tregionId:       uint8(packed >> 240),\n\t\t\tx:              uint16(packed >> 224),\n\t\t\ty:              uint16(packed >> 208),\n\t\t\ttierId:         uint8(packed >> 200),\n\t\t\tsize:           uint16(packed >> 184),\n\t\t\tlandmarkTypeId: uint8(packed >> 176),\n\t\t\telementSites:   uint8(packed >> 168),\n\t\t\tfuelSites:      uint8(packed >> 160),\n\t\t\tseed:           uint160(packed)\n\t\t});\n\t}\n\n\t/**\n\t * @dev Expands `PlotStore` data struct into a `PlotView` view struct\n\t *\n\t * @dev Derives internal land structure (resource sites the plot has)\n\t *      from Number of Element/Fuel Sites, Plot Size, and Seed;\n\t *      Generator Version is not currently used\n\t *\n\t * @param store on-chain `PlotStore` data structure to expand\n\t * @return `PlotView` view struct, expanded from the on-chain data\n\t */\n\tfunction plotView(PlotStore memory store) internal pure returns (PlotView memory) {\n\t\t// copy most of the fields as is, derive resource sites array inline\n\t\treturn PlotView({\n\t\t\tregionId:       store.regionId,\n\t\t\tx:              store.x,\n\t\t\ty:              store.y,\n\t\t\ttierId:         store.tierId,\n\t\t\tsize:           store.size,\n\t\t\tlandmarkTypeId: store.landmarkTypeId,\n\t\t\telementSites:   store.elementSites,\n\t\t\tfuelSites:      store.fuelSites,\n\t\t\t// derive the resource sites from Number of Element/Fuel Sites, Plot Size, and Seed\n\t\t\tsites:          getResourceSites(store.seed, store.elementSites, store.fuelSites, store.size, 2)\n\t\t});\n\t}\n\n\t/**\n\t * @dev Based on the random seed, tier ID, and plot size, determines the\n\t *      internal land structure (resource sites the plot has)\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @param seed random seed to consume and derive the internal structure\n\t * @param elementSites number of element sites plot has\n\t * @param fuelSites number of fuel sites plot has\n\t * @param gridSize plot size `N` of the land plot to derive internal structure for\n\t * @param siteSize implied size `n` of the resource sites\n\t * @return sites randomized array of resource sites\n\t */\n\tfunction getResourceSites(\n\t\tuint256 seed,\n\t\tuint8 elementSites,\n\t\tuint8 fuelSites,\n\t\tuint16 gridSize,\n\t\tuint8 siteSize\n\t) internal pure returns (Site[] memory sites) {\n\t\t// derive the total number of sites\n\t\tuint8 totalSites = elementSites + fuelSites;\n\n\t\t// denote the grid (plot) size `N`\n\t\t// denote the resource site size `n`\n\n\t\t// transform coordinate system (1): normalization (x, y) => (x / n, y / n)\n\t\t// if `N` is odd this cuts off border coordinates x = N - 1, y = N - 1\n\t\tuint16 normalizedSize = gridSize / siteSize;\n\n\t\t// after normalization (1) is applied, isomorphic grid becomes effectively larger\n\t\t// due to borders capturing effect, for example if N = 4, and n = 2:\n\t\t//      | .. |                                              |....|\n\t\t// grid |....| becomes |..| normalized which is effectively |....|\n\t\t//      |....|         |..|                                 |....|\n\t\t//      | .. |                                              |....|\n\t\t// transform coordinate system (2): cut the borders, and reduce grid size to be multiple of 2\n\t\t// if `N/2` is odd this cuts off border coordinates x = N/2 - 1, y = N/2 - 1\n\t\tnormalizedSize = (normalizedSize - 2) / 2 * 2;\n\n\t\t// define coordinate system: an isomorphic grid on a square of size [size, size]\n\t\t// transform coordinate system (3): pack an isomorphic grid on a rectangle of size [size, 1 + size / 2]\n\t\t// transform coordinate system (4): (x, y) -> y * size + x (two-dimensional Cartesian -> one-dimensional segment)\n\t\t// define temporary array to determine sites' coordinates\n\t\tuint16[] memory coords;\n\t\t// generate site coordinates in a transformed coordinate system (on a one-dimensional segment)\n\t\t// cut off four elements in the end of the segment to reserve space in the center for a landmark\n\t\t(seed, coords) = getCoords(seed, totalSites, normalizedSize * (1 + normalizedSize / 2) - 4);\n\n\t\t// allocate number of sites required\n\t\tsites = new Site[](totalSites);\n\n\t\t// define the variables used inside the loop outside the loop to help compiler optimizations\n\t\t// site type ID is de facto uint8, we're using uint16 for convenience with `nextRndUint16`\n\t\tuint16 typeId;\n\t\t// site coordinates (x, y)\n\t\tuint16 x;\n\t\tuint16 y;\n\n\t\t// determine the element and fuel sites one by one\n\t\tfor(uint8 i = 0; i < totalSites; i++) {\n\t\t\t// determine next random number in the sequence, and random site type from it\n\t\t\t(seed, typeId) = nextRndUint16(seed, i < elementSites? 1: 4, 3);\n\n\t\t\t// determine x and y\n\t\t\t// reverse transform coordinate system (4): x = size % i, y = size / i\n\t\t\t// (back from one-dimensional segment to two-dimensional Cartesian)\n\t\t\tx = coords[i] % normalizedSize;\n\t\t\ty = coords[i] / normalizedSize;\n\n\t\t\t// reverse transform coordinate system (3): unpack isomorphic grid onto a square of size [size, size]\n\t\t\t// fix the \"(0, 0) left-bottom corner\" of the isomorphic grid\n\t\t\tif(2 * (1 + x + y) < normalizedSize) {\n\t\t\t\tx += normalizedSize / 2;\n\t\t\t\ty += 1 + normalizedSize / 2;\n\t\t\t}\n\t\t\t// fix the \"(size, 0) right-bottom corner\" of the isomorphic grid\n\t\t\telse if(2 * x > normalizedSize && 2 * x > 2 * y + normalizedSize) {\n\t\t\t\tx -= normalizedSize / 2;\n\t\t\t\ty += 1 + normalizedSize / 2;\n\t\t\t}\n\n\t\t\t// move the site from the center (four positions near the center) to a free spot\n\t\t\tif(x >= normalizedSize / 2 - 1 && x <= normalizedSize / 2\n\t\t\t&& y >= normalizedSize / 2 - 1 && y <= normalizedSize / 2) {\n\t\t\t\t// `x` is aligned over the free space in the end of the segment\n\t\t\t\t// x += normalizedSize / 2 + 2 * (normalizedSize / 2 - x) + 2 * (normalizedSize / 2 - y) - 4;\n\t\t\t\tx += 5 * normalizedSize / 2 - 2 * (x + y) - 4;\n\t\t\t\t// `y` is fixed over the free space in the end of the segment\n\t\t\t\ty = normalizedSize / 2;\n\t\t\t}\n\n\t\t\t// if `N/2` is odd recover previously cut off border coordinates x = N/2 - 1, y = N/2 - 1\n\t\t\t// if `N` is odd recover previously cut off border coordinates x = N - 1, y = N - 1\n\t\t\tuint16 offset = gridSize / siteSize % 2 + gridSize % siteSize;\n\n\t\t\t// based on the determined site type and coordinates, allocate the site\n\t\t\tsites[i] = Site({\n\t\t\t\ttypeId: uint8(typeId),\n\t\t\t\t// reverse transform coordinate system (2): recover borders (x, y) => (x + 1, y + 1)\n\t\t\t\t// if `N/2` is odd recover previously cut off border coordinates x = N/2 - 1, y = N/2 - 1\n\t\t\t\t// reverse transform coordinate system (1): (x, y) => (n * x, n * y), where n is site size\n\t\t\t\t// if `N` is odd recover previously cut off border coordinates x = N - 1, y = N - 1\n\t\t\t\tx: (1 + x) * siteSize + offset,\n\t\t\t\ty: (1 + y) * siteSize + offset\n\t\t\t});\n\t\t}\n\n\t\t// return the result\n\t\treturn sites;\n\t}\n\n\t/**\n\t * @dev Based on the random seed and tier ID determines the landmark type of the plot.\n\t *      Random seed is consumed for tiers 3 and 4 to randomly determine one of three\n\t *      possible landmark types.\n\t *      Tier 5 has its landmark type predefined (arena), lower tiers don't have a landmark.\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @param seed random seed to consume and derive the landmark type based on\n\t * @param tierId tier ID of the land plot\n\t * @return landmarkTypeId landmark type defined by its ID\n\t */\n\tfunction getLandmark(uint256 seed, uint8 tierId) internal pure returns (uint8 landmarkTypeId) {\n\t\t// depending on the tier, land plot can have a landmark\n\t\t// tier 3 has an element landmark (1, 2, 3)\n\t\tif(tierId == 3) {\n\t\t\t// derive random element landmark\n\t\t\treturn uint8(1 + seed % 3);\n\t\t}\n\t\t// tier 4 has a fuel landmark (4, 5, 6)\n\t\tif(tierId == 4) {\n\t\t\t// derive random fuel landmark\n\t\t\treturn uint8(4 + seed % 3);\n\t\t}\n\t\t// tier 5 has an arena landmark\n\t\tif(tierId == 5) {\n\t\t\t// 7 - arena landmark\n\t\t\treturn 7;\n\t\t}\n\n\t\t// lower tiers (0, 1, 2) don't have any landmark\n\t\t// tiers greater than 5 are not defined\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @dev Derives an array of integers with no duplicates from the random seed;\n\t *      each element in the array is within [0, size) bounds and represents\n\t *      a two-dimensional Cartesian coordinate point (x, y) presented as one-dimensional\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive coordinates from\n\t * @param length number of elements to generate\n\t * @param size defines array element bounds [0, size)\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t * @return coords the resulting array of length `n` with random non-repeating elements\n\t *      in [0, size) range\n\t */\n\tfunction getCoords(\n\t\tuint256 seed,\n\t\tuint8 length,\n\t\tuint16 size\n\t) internal pure returns (uint256 nextSeed, uint16[] memory coords) {\n\t\t// allocate temporary array to store (and determine) sites' coordinates\n\t\tcoords = new uint16[](length);\n\n\t\t// generate site coordinates one by one\n\t\tfor(uint8 i = 0; i < coords.length; i++) {\n\t\t\t// get next number and update the seed\n\t\t\t(seed, coords[i]) = nextRndUint16(seed, 0, size);\n\t\t}\n\n\t\t// sort the coordinates\n\t\tsort(coords);\n\n\t\t// find the if there are any duplicates, and while there are any\n\t\tfor(int256 i = findDup(coords); i >= 0; i = findDup(coords)) {\n\t\t\t// regenerate the element at duplicate position found\n\t\t\t(seed, coords[uint256(i)]) = nextRndUint16(seed, 0, size);\n\t\t\t// sort the coordinates again\n\t\t\t// TODO: check if this doesn't degrade the performance significantly (note the pivot in quick sort)\n\t\t\tsort(coords);\n\t\t}\n\n\t\t// shuffle the array to compensate for the sorting made before\n\t\tseed = shuffle(seed, coords);\n\n\t\t// return the updated used seed, and generated coordinates\n\t\treturn (seed, coords);\n\t}\n\n\t/**\n\t * @dev Based on the random seed, generates next random seed, and a random value\n\t *      not lower than given `offset` value and able to have `options` different\n\t *      possible values\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive next random value from\n\t * @param offset the minimum possible output\n\t * @param options number of different possible values to output\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t * @return rndVal random value in the [offset, offset + options) range\n\t */\n\tfunction nextRndUint16(\n\t\tuint256 seed,\n\t\tuint16 offset,\n\t\tuint16 options\n\t) internal pure returns (\n\t\tuint256 nextSeed,\n\t\tuint16 rndVal\n\t) {\n\t\t// generate next random seed first\n\t\tnextSeed = uint256(keccak256(abi.encodePacked(seed)));\n\n\t\t// derive random value with the desired properties from\n\t\t// the newly generated seed\n\t\trndVal = offset + uint16(nextSeed % options);\n\n\t\t// return the result as tuple\n\t\treturn (nextSeed, rndVal);\n\t}\n\n\t/**\n\t * @dev Plot location is a combination of (regionId, x, y), it's effectively\n\t *      a 3-dimensional coordinate, unique for each plot\n\t *\n\t * @dev The function extracts plot location from the plot and represents it\n\t *      in a packed form of 3 integers constituting the location: regionId | x | y\n\t *\n\t * @param plot `PlotView` view structure to extract location from\n\t * @return Plot location (regionId, x, y) as a packed integer\n\t */\n/*\n\tfunction loc(PlotView memory plot) internal pure returns (uint40) {\n\t\t// tightly pack the location data and return\n\t\treturn uint40(plot.regionId) << 32 | uint32(plot.y) << 16 | plot.x;\n\t}\n*/\n\n\t/**\n\t * @dev Plot location is a combination of (regionId, x, y), it's effectively\n\t *      a 3-dimensional coordinate, unique for each plot\n\t *\n\t * @dev The function extracts plot location from the plot and represents it\n\t *      in a packed form of 3 integers constituting the location: regionId | x | y\n\t *\n\t * @param plot `PlotStore` data store structure to extract location from\n\t * @return Plot location (regionId, x, y) as a packed integer\n\t */\n\tfunction loc(PlotStore memory plot) internal pure returns (uint40) {\n\t\t// tightly pack the location data and return\n\t\treturn uint40(plot.regionId) << 32 | uint32(plot.y) << 16 | plot.x;\n\t}\n\n\t/**\n\t * @dev Site location is a combination of (x, y), unique for each site within a plot\n\t *\n\t * @dev The function extracts site location from the site and represents it\n\t *      in a packed form of 2 integers constituting the location: x | y\n\t *\n\t * @param site `Site` view structure to extract location from\n\t * @return Site location (x, y) as a packed integer\n\t */\n/*\n\tfunction loc(Site memory site) internal pure returns (uint32) {\n\t\t// tightly pack the location data and return\n\t\treturn uint32(site.y) << 16 | site.x;\n\t}\n*/\n\n\t/**\n\t * @dev Finds first pair of repeating elements in the array\n\t *\n\t * @dev Assumes the array is sorted ascending:\n\t *      returns `-1` if array is strictly monotonically increasing,\n\t *      index of the first duplicate found otherwise\n\t *\n\t * @param arr an array of elements to check\n\t * @return index found duplicate index, or `-1` if there are no repeating elements\n\t */\n\tfunction findDup(uint16[] memory arr) internal pure returns (int256 index) {\n\t\t// iterate over the array [1, n], leaving the space in the beginning for pair comparison\n\t\tfor(uint256 i = 1; i < arr.length; i++) {\n\t\t\t// verify if there is a strict monotonically increase violation\n\t\t\tif(arr[i - 1] >= arr[i]) {\n\t\t\t\t// return its index if yes\n\t\t\t\treturn int256(i - 1);\n\t\t\t}\n\t\t}\n\n\t\t// return `-1` if no violation was found - array is strictly monotonically increasing\n\t\treturn -1;\n\t}\n\n\t/**\n\t * @dev Shuffles an array if integers by making random permutations\n\t *      in the amount equal to the array size\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive next random value from\n\t * @param arr an array to shuffle\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t */\n\tfunction shuffle(uint256 seed, uint16[] memory arr) internal pure returns(uint256 nextSeed) {\n\t\t// define index `j` to permute with loop index `i` outside the loop to help compiler optimizations\n\t\tuint16 j;\n\n\t\t// iterate over the array one single time\n\t\tfor(uint16 i = 0; i < arr.length; i++) {\n\t\t\t// determine random index `j` to swap with the loop index `i`\n\t\t\t(seed, j) = nextRndUint16(seed, 0, uint16(arr.length));\n\n\t\t\t// do the swap\n\t\t\t(arr[i], arr[j]) = (arr[j], arr[i]);\n\t\t}\n\n\t\t// return the updated used seed\n\t\treturn seed;\n\t}\n\n\t/**\n\t * @dev Sorts an array of integers using quick sort algorithm\n\t *\n\t * @dev Quick sort recursive implementation\n\t *      Source:   https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\n\t *      See also: https://www.geeksforgeeks.org/quick-sort/\n\t *\n\t * @param arr an array to sort\n\t */\n\tfunction sort(uint16[] memory arr) internal pure {\n\t\tquickSort(arr, 0, int256(arr.length) - 1);\n\t}\n\n\t/**\n\t * @dev Quick sort recursive implementation\n\t *      Source:     https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\n\t *      Discussion: https://blog.cotten.io/thinking-in-solidity-6670c06390a9\n\t *      See also:   https://www.geeksforgeeks.org/quick-sort/\n\t */\n\t// TODO: review the implementation code\n\tfunction quickSort(uint16[] memory arr, int256 left, int256 right) private pure {\n\t\tint256 i = left;\n\t\tint256 j = right;\n\t\tif(i >= j) {\n\t\t\treturn;\n\t\t}\n\t\tuint16 pivot = arr[uint256(left + (right - left) / 2)];\n\t\twhile(i <= j) {\n\t\t\twhile(arr[uint256(i)] < pivot) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile(pivot < arr[uint256(j)]) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif(i <= j) {\n\t\t\t\t(arr[uint256(i)], arr[uint256(j)]) = (arr[uint256(j)], arr[uint256(i)]);\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t}\n\t\tif(left < j) {\n\t\t\tquickSort(arr, left, j);\n\t\t}\n\t\tif(i < right) {\n\t\t\tquickSort(arr, i, right);\n\t\t}\n\t}\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev These functions deal with verification of Merkle Trees proofs.\n *\n * The proofs can be generated using the JavaScript library\n * https://github.com/miguelmota/merkletreejs[merkletreejs].\n * Note: the hashing algorithm should be keccak256 and pair sorting should be enabled.\n *\n * See `test/utils/cryptography/MerkleProof.test.js` for some examples.\n */\nlibrary MerkleProof {\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(\n        bytes32[] memory proof,\n        bytes32 root,\n        bytes32 leaf\n    ) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merklee tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     *\n     * _Available since v4.4._\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            bytes32 proofElement = proof[i];\n            if (computedHash <= proofElement) {\n                // Hash(current computed hash + current element of the proof)\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\n            } else {\n                // Hash(current element of the proof + current computed hash)\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\n            }\n        }\n        return computedHash;\n    }\n}\n"
    },
    "contracts/interfaces/ERC165Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title ERC-165 Standard Interface Detection\n *\n * @dev Interface of the ERC165 standard, as defined in the\n *       https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * @dev Implementers can declare support of contract interfaces,\n *      which can then be queried by others.\n *\n * @author Christian Reitwießner, Nick Johnson, Fabian Vogelsteller, Jordi Baylina, Konrad Feldmeier, William Entriken\n */\ninterface ERC165 {\n\t/**\n\t * @notice Query if a contract implements an interface\n\t *\n\t * @dev Interface identification is specified in ERC-165.\n\t *      This function uses less than 30,000 gas.\n\t *\n\t * @param interfaceID The interface identifier, as specified in ERC-165\n\t * @return `true` if the contract implements `interfaceID` and\n\t *      `interfaceID` is not 0xffffffff, `false` otherwise\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool);\n}\n"
    },
    "contracts/token/UpgradeableERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC20Spec.sol\";\nimport \"../interfaces/ERC721SpecExt.sol\";\nimport \"../interfaces/IdentifiableSpec.sol\";\nimport \"../lib/SafeERC20.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol\";\n\n/**\n * @title Upgradeable ERC721 Implementation\n *\n * @notice Zeppelin based ERC721 implementation, supporting token enumeration\n *      (ERC721EnumerableUpgradeable) and flexible token URI management (ERC721URIStorageUpgradeable)\n *\n * // TODO: consider allowing to override each individual token URI\n *\n * @dev Based on Zeppelin ERC721EnumerableUpgradeable and ERC721URIStorageUpgradeable with some modifications\n *      to tokenURI function\n *\n * @author Basil Gorin\n */\nabstract contract UpgradeableERC721 is IdentifiableToken, MintableERC721, BurnableERC721, ERC721EnumerableUpgradeable, ERC721URIStorageUpgradeable, UpgradeableAccessControl {\n\t// using ERC20.transfer wrapper from OpenZeppelin adopted SafeERC20\n\tusing SafeERC20 for ERC20;\n\n\t/**\n\t * @dev Base URI is used to construct ERC721Metadata.tokenURI as\n\t *      `base URI + token ID` if token URI is not set (not present in `_tokenURIs` mapping)\n\t *\n\t * @dev For example, if base URI is https://api.com/token/, then token #1\n\t *      will have an URI https://api.com/token/1\n\t *\n\t * @dev If token URI is set with `setTokenURI()` it will be returned as is via `tokenURI()`\n\t */\n\tstring public baseURI;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[49] private __gap;\n\n\t/**\n\t * @notice Enables ERC721 transfers of the tokens\n\t *      (transfer by the token owner himself)\n\t * @dev Feature FEATURE_TRANSFERS must be enabled in order for\n\t *      `transferFrom()` function to succeed when executed by token owner\n\t */\n\tuint32 public constant FEATURE_TRANSFERS = 0x0000_0001;\n\n\t/**\n\t * @notice Enables ERC721 transfers on behalf\n\t *      (transfer by someone else on behalf of token owner)\n\t * @dev Feature FEATURE_TRANSFERS_ON_BEHALF must be enabled in order for\n\t *      `transferFrom()` function to succeed whe executed by approved operator\n\t * @dev Token owner must call `approve()` or `setApprovalForAll()`\n\t *      first to authorize the transfer on behalf\n\t */\n\tuint32 public constant FEATURE_TRANSFERS_ON_BEHALF = 0x0000_0002;\n\n\t/**\n\t * @notice Enables token owners to burn their own tokens\n\t *\n\t * @dev Feature FEATURE_OWN_BURNS must be enabled in order for\n\t *      `burn()` function to succeed when called by token owner\n\t */\n\tuint32 public constant FEATURE_OWN_BURNS = 0x0000_0008;\n\n\t/**\n\t * @notice Enables approved operators to burn tokens on behalf of their owners\n\t *\n\t * @dev Feature FEATURE_BURNS_ON_BEHALF must be enabled in order for\n\t *      `burn()` function to succeed when called by approved operator\n\t */\n\tuint32 public constant FEATURE_BURNS_ON_BEHALF = 0x0000_0010;\n\n\t/**\n\t * @notice Token creator is responsible for creating (minting)\n\t *      tokens to an arbitrary address\n\t * @dev Role ROLE_TOKEN_CREATOR allows minting tokens\n\t *      (calling `mint` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_CREATOR = 0x0001_0000;\n\n\t/**\n\t * @notice Token destroyer is responsible for destroying (burning)\n\t *      tokens owned by an arbitrary address\n\t * @dev Role ROLE_TOKEN_DESTROYER allows burning tokens\n\t *      (calling `burn` function)\n\t */\n\tuint32 public constant ROLE_TOKEN_DESTROYER = 0x0002_0000;\n\n\t/**\n\t * @notice URI manager is responsible for managing base URI\n\t *      part of the token URI ERC721Metadata interface\n\t *\n\t * @dev Role ROLE_URI_MANAGER allows updating the base URI\n\t *      (executing `setBaseURI` function)\n\t */\n\tuint32 public constant ROLE_URI_MANAGER = 0x0004_0000;\n\n\t/**\n\t * @notice People do mistakes and may send ERC20 tokens by mistake; since\n\t *      NFT smart contract is not designed to accept and hold any ERC20 tokens,\n\t *      it allows the rescue manager to \"rescue\" such lost tokens\n\t *\n\t * @notice Rescue manager is responsible for \"rescuing\" ERC20 tokens accidentally\n\t *      sent to the smart contract\n\t *\n\t * @dev Role ROLE_RESCUE_MANAGER allows withdrawing any ERC20 tokens stored\n\t *      on the smart contract balance\n\t */\n\tuint32 public constant ROLE_RESCUE_MANAGER = 0x0008_0000;\n\n\t/**\n\t * @dev Fired in _mint() and all the dependent functions like mint(), safeMint()\n\t *\n\t * @param _by an address which executed update\n\t * @param _to an address token was minted to\n\t * @param _tokenId token ID minted\n\t */\n\tevent Minted(address indexed _by, address indexed _to, uint256 indexed _tokenId);\n\n\t/**\n\t * @dev Fired in _burn() and all the dependent functions like burn()\n\t *\n\t * @param _by an address which executed update\n\t * @param _from an address token was burnt from\n\t * @param _tokenId token ID burnt\n\t */\n\tevent Burnt(address indexed _by, address indexed _from, uint256 indexed _tokenId);\n\n\t/**\n\t * @dev Fired in setBaseURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param oldVal old _baseURI value\n\t * @param newVal new _baseURI value\n\t */\n\tevent BaseURIUpdated(address indexed _by, string oldVal, string newVal);\n\n\t/**\n\t * @dev Fired in setTokenURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param tokenId token ID which URI was updated\n\t * @param oldVal old _baseURI value\n\t * @param newVal new _baseURI value\n\t */\n\tevent TokenURIUpdated(address indexed _by, uint256 tokenId, string oldVal, string newVal);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(string memory _name, string memory _symbol, address _owner) internal virtual initializer {\n\t\t// execute all parent initializers in cascade\n\t\t__ERC721_init(_name, _symbol);\n\t\t__ERC721Enumerable_init_unchained();\n\t\t__ERC721URIStorage_init_unchained();\n\t\tUpgradeableAccessControl._postConstruct(_owner);\n\t}\n\n\t/**\n\t * @inheritdoc IERC165Upgradeable\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) returns (bool) {\n\t\t// calculate based on own and inherited interfaces\n\t\treturn ERC721EnumerableUpgradeable.supportsInterface(interfaceId)\n\t\t\t|| interfaceId == type(MintableERC721).interfaceId\n\t\t\t|| interfaceId == type(BurnableERC721).interfaceId;\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates base URI used to construct\n\t *      ERC721Metadata.tokenURI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param __baseURI new base URI to set\n\t */\n\tfunction setBaseURI(string memory __baseURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit BaseURIUpdated(msg.sender, baseURI, __baseURI);\n\n\t\t// and update base URI\n\t\tbaseURI = __baseURI;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Upgradeable\n\t */\n\tfunction _baseURI() internal view virtual override returns (string memory) {\n\t\t// just return stored public value to support Zeppelin impl\n\t\treturn baseURI;\n\t}\n\n\t/**\n\t * @dev Sets the token URI for the token defined by its ID\n\t *\n\t * @param _tokenId an ID of the token to set URI for\n\t * @param _tokenURI token URI to set\n\t */\n\tfunction setTokenURI(uint256 _tokenId, string memory _tokenURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// we do not verify token existence: we want to be able to\n\t\t// preallocate token URIs before tokens are actually minted\n\n\t\t// emit an event first - to log both old and new values\n\t\temit TokenURIUpdated(msg.sender, _tokenId, \"zeppelin\", _tokenURI);\n\n\t\t// and update token URI - delegate to ERC721URIStorage\n\t\t_setTokenURI(_tokenId, _tokenURI);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721URIStorageUpgradeable\n\t */\n\tfunction _setTokenURI(uint256 _tokenId, string memory _tokenURI) internal virtual override {\n\t\t// delegate to ERC721URIStorage impl\n\t\treturn super._setTokenURI(_tokenId, _tokenURI);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Upgradeable\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) returns (string memory) {\n\t\t// delegate to ERC721URIStorage impl\n\t\treturn ERC721URIStorageUpgradeable.tokenURI(_tokenId);\n\t}\n\n\t/**\n\t * @notice Checks if specified token exists\n\t *\n\t * @dev Returns whether the specified token ID has an ownership\n\t *      information associated with it\n\t * @param _tokenId ID of the token to query existence for\n\t * @return whether the token exists (true - exists, false - doesn't exist)\n\t */\n\tfunction exists(uint256 _tokenId) public view virtual override returns (bool) {\n\t\t// delegate to super implementation\n\t\treturn _exists(_tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Prefer the use of `saveMint` instead of `mint`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction mint(address _to, uint256 _tokenId) public virtual override {\n\t\t// mint token - delegate to `_mint`\n\t\t_mint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t * @param _data additional data with no specified format, sent in call to `_to`\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId, bytes memory _data) public virtual override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId, _data);\n\t}\n\n\t/**\n\t * @dev Creates new token with token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Checks if `_to` is a smart contract (code size > 0). If so, it calls\n\t *      `onERC721Received` on `_to` and throws if the return value is not\n\t *      `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_CREATOR` permission\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId ID of the token to mint\n\t */\n\tfunction safeMint(address _to, uint256 _tokenId) public virtual override {\n\t\t// mint token safely - delegate to `_safeMint`\n\t\t_safeMint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Destroys the token with token ID specified\n\t *\n\t * @dev Requires executor to have `ROLE_TOKEN_DESTROYER` permission\n\t *      or FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features to be enabled\n\t *\n\t * @dev Can be disabled by the contract creator forever by disabling\n\t *      FEATURE_OWN_BURNS/FEATURE_BURNS_ON_BEHALF features and then revoking\n\t *      its own roles to burn tokens and to enable burning features\n\t *\n\t * @param _tokenId ID of the token to burn\n\t */\n\tfunction burn(uint256 _tokenId) public virtual override {\n\t\t// burn token - delegate to `_burn`\n\t\t_burn(_tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Upgradeable\n\t */\n\tfunction _mint(address _to, uint256 _tokenId) internal virtual override {\n\t\t// check if caller has sufficient permissions to mint tokens\n\t\trequire(isSenderInRole(ROLE_TOKEN_CREATOR), \"access denied\");\n\n\t\t// delegate to super implementation\n\t\tsuper._mint(_to, _tokenId);\n\n\t\t// emit an additional event to better track who performed the operation\n\t\temit Minted(msg.sender, _to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Upgradeable\n\t */\n\tfunction _burn(uint256 _tokenId) internal virtual override(ERC721Upgradeable, ERC721URIStorageUpgradeable) {\n\t\t// read token owner data\n\t\t// verifies token exists under the hood\n\t\taddress _from = ownerOf(_tokenId);\n\n\t\t// check if caller has sufficient permissions to burn tokens\n\t\t// and if not - check for possibility to burn own tokens or to burn on behalf\n\t\tif(!isSenderInRole(ROLE_TOKEN_DESTROYER)) {\n\t\t\t// if `_from` is equal to sender, require own burns feature to be enabled\n\t\t\t// otherwise require burns on behalf feature to be enabled\n\t\t\trequire(_from == msg.sender && isFeatureEnabled(FEATURE_OWN_BURNS)\n\t\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_BURNS_ON_BEHALF),\n\t\t\t        _from == msg.sender? \"burns are disabled\": \"burns on behalf are disabled\");\n\n\t\t\t// verify sender is either token owner, or approved by the token owner to burn tokens\n\t\t\trequire(msg.sender == _from\n\t\t\t     || msg.sender == getApproved(_tokenId)\n\t\t\t     || isApprovedForAll(_from, msg.sender), \"access denied\");\n\t\t}\n\n\t\t// delegate to the super implementation with URI burning\n\t\tERC721URIStorageUpgradeable._burn(_tokenId);\n\n\t\t// emit an additional event to better track who performed the operation\n\t\temit Burnt(msg.sender, _from, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Upgradeable\n\t */\n\tfunction _beforeTokenTransfer(\n\t\taddress _from,\n\t\taddress _to,\n\t\tuint256 _tokenId\n\t) internal virtual override(ERC721Upgradeable, ERC721EnumerableUpgradeable) {\n\t\t// for transfers only - verify if transfers are enabled\n\t\trequire(_from == address(0) || _to == address(0) // won't affect minting/burning\n\t\t     || _from == msg.sender && isFeatureEnabled(FEATURE_TRANSFERS)\n\t\t     || _from != msg.sender && isFeatureEnabled(FEATURE_TRANSFERS_ON_BEHALF),\n\t\t        _from == msg.sender? \"transfers are disabled\": \"transfers on behalf are disabled\");\n\n\t\t// delegate to ERC721Enumerable impl\n\t\tERC721EnumerableUpgradeable._beforeTokenTransfer(_from, _to, _tokenId);\n\t}\n\n\t/**\n\t * @dev Restricted access function to rescue accidentally sent ERC20 tokens,\n\t *      the tokens are rescued via `transfer` function call on the\n\t *      contract address specified and with the parameters specified:\n\t *      `_contract.transfer(_to, _value)`\n\t *\n\t * @dev Requires executor to have `ROLE_RESCUE_MANAGER` permission\n\t *\n\t * @param _contract smart contract address to execute `transfer` function on\n\t * @param _to to address in `transfer(_to, _value)`\n\t * @param _value value to transfer in `transfer(_to, _value)`\n\t */\n\tfunction rescueErc20(address _contract, address _to, uint256 _value) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_RESCUE_MANAGER), \"access denied\");\n\n\t\t// perform the transfer as requested, without any checks\n\t\tERC20(_contract).safeTransfer(_to, _value);\n\t}\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721Enumerable_init_unchained();\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721URIStorageUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorageUpgradeable is Initializable, ERC721Upgradeable {\n    function __ERC721URIStorage_init() internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721URIStorage_init_unchained();\n    }\n\n    function __ERC721URIStorage_init_unchained() internal onlyInitializing {\n    }\n    using StringsUpgradeable for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721URIStorage: URI query for nonexistent token\");\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __Context_init_unchained();\n        __ERC165_init_unchained();\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: balance query for the zero address\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: owner query for nonexistent token\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        require(_exists(tokenId), \"ERC721Metadata: URI query for nonexistent token\");\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overriden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        require(_exists(tokenId), \"ERC721: approved query for nonexistent token\");\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: transfer caller is not owner nor approved\");\n        _safeTransfer(from, to, tokenId, _data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `_data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, _data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        require(_exists(tokenId), \"ERC721: operator query for nonexistent token\");\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || getApproved(tokenId) == spender || isApprovedForAll(owner, spender));\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, _data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer of token that is not own\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits a {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits a {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param _data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory _data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, _data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 tokenId);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n        __Context_init_unchained();\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n        __ERC165_init_unchained();\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/mocks/UpgradeableERC721Mocks.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/UpgradeableERC721.sol\";\n\n/**\n * @title Zeppelin ERC721 Mock\n *\n * @notice Zeppelin ERC721 Mock simulates an NFT token, used for testing purposes;\n *      it still has restricted access to the mint() function\n *\n * @author Basil Gorin\n */\ncontract UpgradeableERC721Mock is UpgradeableERC721 {\n\t/**\n\t * @inheritdoc IdentifiableToken\n\t */\n\tuint256 public override TOKEN_UID = 0x5c1ffff5909ddefd4412fc7e5c5596fb67bd289d64e1ae9f4322be69ac82dc0b;\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tfunction postConstruct(string memory _name, string memory _symbol) public virtual initializer {\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableERC721._postConstruct(_name, _symbol, msg.sender);\n\t}\n}\n\n/**\n * @title Zeppelin ERC721 Mock\n *\n * @notice Zeppelin ERC721 Mock simulates an NFT token, used for testing purposes;\n *      it still has restricted access to the mint() function\n *\n * @author Basil Gorin\n */\ncontract UpgradeableERC721Mock2 is UpgradeableERC721Mock {\n\t// add version!\n\tstring public version;\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tfunction postConstruct(string memory _name, string memory _symbol) public virtual override initializer {\n\t\t// execute all parent initializers in cascade\n\t\tsuper._postConstruct(_name, _symbol, msg.sender);\n\n\t\t// set thee version!\n\t\tversion = \"Version 2 (Upgraded)!\";\n\t}\n}\n"
    },
    "contracts/token/RoyalERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/EIP2981Spec.sol\";\nimport \"./UpgradeableERC721.sol\";\n\n/**\n * @title Royal ER721\n *\n * @dev Supports EIP-2981 royalties on NFT secondary sales\n *      Supports OpenSea contract metadata royalties\n *      Introduces fake \"owner\" to support OpenSea collections\n *\n * @author Basil Gorin\n */\nabstract contract RoyalERC721 is EIP2981, UpgradeableERC721 {\n\t/**\n\t * @dev OpenSea expects NFTs to be \"Ownable\", that is having an \"owner\",\n\t *      we introduce a fake \"owner\" here with no authority\n\t */\n\taddress public owner;\n\n\t/**\n\t * @notice Address to receive EIP-2981 royalties from secondary sales\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t */\n\taddress public royaltyReceiver;\n\n\t/**\n\t * @notice Percentage of token sale price to be used for EIP-2981 royalties from secondary sales\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t *\n\t * @dev Has 2 decimal precision. E.g. a value of 500 would result in a 5% royalty fee\n\t */\n\tuint16 public royaltyPercentage; // default OpenSea value is 750\n\n\t/**\n\t * @notice Contract level metadata to define collection name, description, and royalty fees.\n\t *         see https://docs.opensea.io/docs/contract-level-metadata\n\t *\n\t * @dev Should be set by URI manager, empty by default\n\t */\n\tstring public contractURI;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t *\n\t * @dev Note: `owner`, `royaltyReceiver`, `royaltyPercentage`, and `contractURI` occupy\n\t *      only 3 storage slots (not 4) since `royaltyReceiver` and `royaltyPercentage` fit\n\t *      into a single storage slot (160 + 16 bits)\n\t */\n\tuint256[47] private __gap;\n\n\t/**\n\t * @notice Royalty manager is responsible for managing the EIP2981 royalty info\n\t *\n\t * @dev Role ROLE_ROYALTY_MANAGER allows updating the royalty information\n\t *      (executing `setRoyaltyInfo` function)\n\t */\n\tuint32 public constant ROLE_ROYALTY_MANAGER = 0x0010_0000;\n\n\t/**\n\t * @notice Owner manager is responsible for setting/updating an \"owner\" field\n\t *\n\t * @dev Role ROLE_OWNER_MANAGER allows updating the \"owner\" field\n\t *      (executing `setOwner` function)\n\t */\n\tuint32 public constant ROLE_OWNER_MANAGER = 0x0020_0000;\n\n\t/**\n\t * @dev Fired in setContractURI()\n\t *\n\t * @param _by an address which executed update\n\t * @param _value new contractURI value\n\t */\n\tevent ContractURIUpdated(address indexed _by, string _value);\n\n\t/**\n\t * @dev Fired in setRoyaltyInfo()\n\t *\n\t * @param _by an address which executed update\n\t * @param _receiver new royaltyReceiver value\n\t * @param _percentage new royaltyPercentage value\n\t */\n\tevent RoyaltyInfoUpdated(\n\t\taddress indexed _by,\n\t\taddress indexed _receiver,\n\t\tuint16 _percentage\n\t);\n\n\t/**\n\t * @dev Fired in setOwner()\n\t *\n\t * @param _by an address which set the new \"owner\"\n\t * @param _oldVal previous \"owner\" address\n\t * @param _newVal new \"owner\" address\n\t */\n\tevent OwnerUpdated(address indexed _by, address indexed _oldVal, address indexed _newVal);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t * @param _owner smart contract owner having full privileges\n\t */\n\tfunction _postConstruct(string memory _name, string memory _symbol, address _owner) internal virtual override initializer {\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableERC721._postConstruct(_name, _symbol, _owner);\n\n\t\t// initialize the \"owner\" as a deployer account\n\t\towner = msg.sender;\n\n\t\t// contractURI is as an empty string by default (zero-length array)\n\t\t// contractURI = \"\";\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates the contract URI\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _contractURI new contract URI to set\n\t */\n\tfunction setContractURI(string memory _contractURI) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// update the contract URI\n\t\tcontractURI = _contractURI;\n\n\t\t// emit an event\n\t\temit ContractURIUpdated(msg.sender, _contractURI);\n\t}\n\n\t/**\n\t * @notice EIP-2981 function to calculate royalties for sales in secondary marketplaces.\n\t *         see https://eips.ethereum.org/EIPS/eip-2981\n\t *\n\t * @inheritdoc EIP2981\n\t */\n\tfunction royaltyInfo(\n\t\tuint256,\n\t\tuint256 _salePrice\n\t) public view virtual override returns (\n\t\taddress receiver,\n\t\tuint256 royaltyAmount\n\t) {\n\t\t// simply calculate the values and return the result\n\t\treturn (royaltyReceiver, _salePrice * royaltyPercentage / 100_00);\n\t}\n\n\t/**\n\t * @dev Restricted access function which updates the royalty info\n\t *\n\t * @dev Requires executor to have ROLE_ROYALTY_MANAGER permission\n\t *\n\t * @param _royaltyReceiver new royalty receiver to set\n\t * @param _royaltyPercentage new royalty percentage to set\n\t */\n\tfunction setRoyaltyInfo(address _royaltyReceiver, uint16 _royaltyPercentage) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_ROYALTY_MANAGER), \"access denied\");\n\n\t\t// verify royalty percentage is zero if receiver is also zero\n\t\trequire(_royaltyReceiver != address(0) || _royaltyPercentage == 0, \"invalid receiver\");\n\t\t// verify royalty percentage doesn't exceed 100%\n\t\trequire(_royaltyPercentage <= 100_00, \"royalty percentage exceeds 100%\");\n\n\t\t// update the values\n\t\troyaltyReceiver = _royaltyReceiver;\n\t\troyaltyPercentage = _royaltyPercentage;\n\n\t\t// emit an event\n\t\temit RoyaltyInfoUpdated(msg.sender, _royaltyReceiver, _royaltyPercentage);\n\t}\n\n\t/**\n\t * @notice Checks if the address supplied is an \"owner\" of the smart contract\n\t *      Note: an \"owner\" doesn't have any authority on the smart contract and is \"nominal\"\n\t *\n\t * @return true if the caller is the current owner.\n\t */\n\tfunction isOwner(address _addr) public view virtual returns (bool) {\n\t\t// just evaluate and return the result\n\t\treturn _addr == owner;\n\t}\n\n\t/**\n\t * @dev Restricted access function to set smart contract \"owner\"\n\t *      Note: an \"owner\" set doesn't have any authority, and cannot even update \"owner\"\n\t *\n\t * @dev Requires executor to have ROLE_OWNER_MANAGER permission\n\t *\n\t * @param _owner new \"owner\" of the smart contract\n\t */\n\tfunction transferOwnership(address _owner) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_OWNER_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit OwnerUpdated(msg.sender, owner, _owner);\n\n\t\t// update \"owner\"\n\t\towner = _owner;\n\t}\n\n\t/**\n\t * @inheritdoc IERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, UpgradeableERC721) returns (bool) {\n\t\t// construct the interface support from EIP-2981 and super interfaces\n\t\treturn interfaceId == type(EIP2981).interfaceId || super.supportsInterface(interfaceId);\n\t}\n}\n"
    },
    "contracts/interfaces/EIP2981Spec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\n/**\n * @title EIP-2981: NFT Royalty Standard\n *\n * @notice A standardized way to retrieve royalty payment information for non-fungible tokens (NFTs)\n *      to enable universal support for royalty payments across all NFT marketplaces and ecosystem participants.\n *\n * @author Zach Burks, James Morgan, Blaine Malone, James Seibel\n */\ninterface EIP2981 is IERC165 {\n\t/**\n\t * @dev ERC165 bytes to add to interface array - set in parent contract\n\t *      implementing this standard:\n\t *      bytes4(keccak256(\"royaltyInfo(uint256,uint256)\")) == 0x2a55205a\n\t *      bytes4 private constant _INTERFACE_ID_ERC2981 = 0x2a55205a;\n\t *      _registerInterface(_INTERFACE_ID_ERC2981);\n\t *\n\t * @notice Called with the sale price to determine how much royalty\n\t *      is owed and to whom.\n\t * @param _tokenId token ID to calculate royalty info for;\n\t *      the NFT asset queried for royalty information\n\t * @param _salePrice the price (in any unit, .e.g wei, ERC20 token, et.c.) of the token to be sold;\n\t *      the sale price of the NFT asset specified by _tokenId\n\t * @return receiver the royalty receiver, an address of who should be sent the royalty payment\n\t * @return royaltyAmount royalty amount in the same unit as _salePrice;\n\t *      the royalty payment amount for _salePrice\n\t */\n\tfunction royaltyInfo(\n\t\tuint256 _tokenId,\n\t\tuint256 _salePrice\n\t) external view returns (\n\t\taddress receiver,\n\t\tuint256 royaltyAmount\n\t);\n}\n"
    },
    "contracts/token/LandERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ImmutableSpec.sol\";\nimport \"../interfaces/LandERC721Spec.sol\";\nimport \"../lib/LandLib.sol\";\nimport \"../lib/LandBlobLib.sol\";\nimport \"./RoyalERC721.sol\";\n\n/**\n * @title Land ERC721\n *\n * @notice Land ERC721 (a.k.a Land Plot, Land, or Land NFT) represents land plots in Illuvium: Zero (IZ).\n *      Each token is a piece of land (land plot) on the overall world map in IZ.\n *\n * @notice Land plot is uniquely identified by its region and coordinates (x, y) within the region.\n *      There can be only one plot with the given coordinates (x, y) in a given region.\n *\n * @notice Land plot has internal coordinate system used to place the structures (off-chain).\n *      Land plot may contain \"sites\" with the resources,\n *      a Landmark, increasing the resource production / decreasing resource losses,\n *      or a special type of Landmark - Arena, used to host tournaments.\n *      Sites are positioned on the plot and have their own coordinates (x, y) within a plot.\n *      Number of sites depends on the land plot rarity (tier).\n *      Landmark may exist only in the rare land plots (tier 3 or higher) and resides in the center of the plot.\n *\n * @notice Land plot does not contain details on the structures, these details are stored off-chain.\n *      The fundamental value of the Land is always drawn from the underlying Land NFT,\n *      which produces Fuel in the form of an ERC20 tokens.\n *\n * @notice Land plot metadata is immutable and includes (see `LandView` structure):\n *      - Region ID (1 - 7), determines which tileset to use in game,\n *      - Coordinates (x, y) on the overall world map, indicating which grid position the land sits in,\n *      - Tier ID (1 - 5), the rarity of the land, tier is used to create the list of sites,\n *      - Plot Size, defines an internal coordinate system within a plot,\n *      - Internal Land Structure\n *        - enumeration of sites, each site metadata including:\n *          - Type ID (1 - 6), defining the type of the site:\n *            1) Carbon,\n *            2) Silicon,\n *            3) Hydrogen,\n *            4) Crypton,\n *            5) Hyperion,\n *            6) Solon\n *          - Coordinates (x, y) on the land plot\n *        - Landmark Type ID:\n *            0) no Landmark,\n *            1) Carbon Landmark,\n *            2) Silicon Landmark,\n *            3) Hydrogen Landmark (Eternal Spring),\n *            4) Crypton Landmark,\n *            5) Hyperion Landmark,\n *            6) Solon Landmark (Fallen Star),\n *            7) Arena\n *\n * @notice Region ID, Coordinates (x, y), Tier ID, and Plot Size are stored as is, while Internal Land Structure\n *      is derived from Tier ID, Plot Size, and a Seed (see `LandStore` structure)\n *\n * @notice A note on Region, Coordinates (x, y), Tier, Plot Size, and Internal Land Structure.\n *      Land Plot smart contract stores Region, Coordinates (x, y), Tier, Plot Size, and Internal Land Structure\n *      as part of the land metadata on-chain, however the use of these values within the smart contract is limited.\n *      Effectively that means that helper smart contracts, backend, or frontend applications can, to some extent,\n *      treat these values at their own decision, may redefine, enrich, or ignore their meaning.\n *\n * @notice Land NFTs are minted by the trusted helper smart contract(s) (see `LandSale`), which are responsible\n *      for supplying the correct metadata.\n *      Land NFT contract itself doesn't store the Merkle root of the valid land metadata, and\n *      has a limited constraint validation for NFTs it mints/tracks, it guarantees:\n *         - (regionId, x, y) uniqueness\n *         - non-intersection of the sites coordinates within a plot\n *         - correspondence of the number of resource sites and their types to the land tier\n *         - correspondence of the landmark type to the land tier\n *\n * @dev Minting a token requires its metadata to be supplied before or during the minting process;\n *      Burning the token destroys its metadata;\n *      Metadata can be pre-allocated: it can be set/updated/removed for non-existing tokens, and\n *      once the token is minted, its metadata becomes \"frozen\" - immutable, it cannot be changed or removed.\n *\n * @notice Refer to \"Illuvium: Zero\" design documents for additional information about the game.\n *      Refer to \"Illuvium Land Sale On-chain Architecture\" for additional information about\n *      the technical design of the Land ERC721 token and Land Sale smart contracts and their interaction.\n *\n * @author Basil Gorin\n */\ncontract LandERC721 is RoyalERC721, LandERC721Metadata, ImmutableMintableERC721 {\n\t// Use Land Library to generate Internal Land Structure, extract plot coordinates,\n\t// pack/unpack `PlotStore` to/from uint256, etc.\n\tusing LandLib for LandLib.PlotView;\n\tusing LandLib for LandLib.PlotStore;\n\tusing LandLib for uint256;\n\n\t/**\n\t * @inheritdoc IdentifiableToken\n\t */\n\tuint256 public constant override TOKEN_UID = 0x805d1eb685f9eaad4306ed05ef803361e9c0b3aef93774c4b118255ab3f9c7d1;\n\n\t/**\n\t * @notice If set, land descriptor overrides the default behavior of `tokenURI`\n\t *      ERC721 by delegating URI generation to an external address;\n\t *      this can be used, for example, to render base64-encoded SVG image\n\t *      as a token URI\n\t *\n\t * @dev Can be added/removed/updated via `setLandDescriptor()` function\n\t */\n\taddress public landDescriptor;\n\n\t/**\n\t * @notice Metadata storage for tokens (land plots)\n\t * @notice Accessible via `getMetadata(uint256)`\n\t *\n\t * @dev Maps token ID => token Metadata (PlotData struct)\n\t */\n\tmapping(uint256 => LandLib.PlotStore) internal plots;\n\n\t/**\n\t * @notice Auxiliary data structure tracking all the occupied land plot\n\t *      locations, and used to guarantee the (regionId, x, y) uniqueness\n\t *\n\t * @dev Maps packed plot location (regionId, x, y) => token ID\n\t */\n\tmapping(uint256 => uint256) public plotLocations;\n\n\t/**\n\t * @dev Empty reserved space in storage. The size of the __gap array is calculated so that\n\t *      the amount of storage used by a contract always adds up to the 50.\n\t *      See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n\t */\n\tuint256[47] private __gap;\n\n\t/**\n\t * @notice Metadata provider is responsible for writing tokens' metadata\n\t *      (for an arbitrary token - be it an existing token or non-existing one)\n\t * @notice The limitation is that for an existing token its metadata can\n\t *      be written only once, it is impossible to modify existing\n\t *      token's metadata, its effectively immutable\n\t *\n\t * @dev Role ROLE_METADATA_PROVIDER allows writing tokens' metadata\n\t *      (calling `setMetadata` function)\n\t * @dev ROLE_TOKEN_CREATOR and ROLE_METADATA_PROVIDER roles are usually\n\t *      used together, since the token should always be created with the\n\t *      metadata supplied\n\t */\n\tuint32 public constant ROLE_METADATA_PROVIDER = 0x0040_0000;\n\n\t/**\n\t * @dev Fired in `setMetadata()` when token metadata is set/updated\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _tokenId token ID which metadata was updated/set\n\t * @param _plot new token metadata\n\t */\n\tevent MetadataUpdated(address indexed _by, uint256 indexed _tokenId, LandLib.PlotStore _plot);\n\n\t/**\n\t * @dev Fired in `removeMetadata()` when token metadata is removed\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _tokenId token ID which metadata was removed\n\t * @param _plot old token metadata (which was removed)\n\t */\n\tevent MetadataRemoved(address indexed _by, uint256 indexed _tokenId, LandLib.PlotStore _plot);\n\n\t/**\n\t * @dev Fired in `setLandDescriptor()` when LandDescriptor implementation\n\t *      is set, updated, or removed (set to zero)\n\t *\n\t * @param _by an address which executed the operation\n\t * @param _oldImpl old LandDescriptor implementation address (or zero)\n\t * @param _newImpl new LandDescriptor implementation address (or zero)\n\t */\n\tevent LandDescriptorUpdated(address indexed _by, address indexed _oldImpl, address indexed _newImpl);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * param _name token name (ERC721Metadata)\n\t * param _symbol token symbol (ERC721Metadata)\n\t */\n\tfunction postConstruct(string memory _name, string memory _symbol) public virtual initializer {\n\t\t// execute all parent initializers in cascade\n\t\tRoyalERC721._postConstruct(_name, _symbol, msg.sender);\n\t}\n\n\t/**\n\t * @inheritdoc IERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// calculate based on own and inherited interfaces\n\t\treturn super.supportsInterface(interfaceId)\n\t\t\t|| interfaceId == type(LandERC721Metadata).interfaceId\n\t\t\t|| interfaceId == type(ImmutableMintableERC721).interfaceId;\n\t}\n\n\t/**\n\t * @notice Presents token metadata in a well readable form,\n\t *      with the Internal Land Structure included, as a `PlotView` struct\n\t *\n\t * @notice Reconstructs the internal land structure of the plot based on the stored\n\t *      Tier ID, Plot Size, Generator Version, and Seed\n\t *\n\t * @param _tokenId token ID to query metadata view for\n\t * @return token metadata as a `PlotView` struct\n\t */\n\tfunction viewMetadata(uint256 _tokenId) public view virtual override returns (LandLib.PlotView memory) {\n\t\t// use Land Library to convert internal representation into the Plot view\n\t\treturn plots[_tokenId].plotView();\n\t}\n\n\t/**\n\t * @notice Presents token metadata \"as is\", without the Internal Land Structure included,\n\t *      as a `PlotStore` struct;\n\t *\n\t * @notice Doesn't reconstruct the internal land structure of the plot, allowing to\n\t *      access Generator Version, and Seed fields \"as is\"\n\t *\n\t * @param _tokenId token ID to query on-chain metadata for\n\t * @return token metadata as a `PlotStore` struct\n\t */\n\tfunction getMetadata(uint256 _tokenId) public view override returns (LandLib.PlotStore memory) {\n\t\t// simply return the plot metadata as it is stored\n\t\treturn plots[_tokenId];\n\t}\n\n\t/**\n\t * @notice Verifies if token has its metadata set on-chain; for the tokens\n\t *      in existence metadata is immutable, it can be set once, and not updated\n\t *\n\t * @dev If `exists(_tokenId) && hasMetadata(_tokenId)` is true, `setMetadata`\n\t *      for such a `_tokenId` will always throw\n\t *\n\t * @param _tokenId token ID to check metadata existence for\n\t * @return true if token ID specified has metadata associated with it\n\t */\n\tfunction hasMetadata(uint256 _tokenId) public view virtual override returns (bool) {\n\t\t// determine plot existence based on its metadata stored\n\t\t// note: size cannot be zero by the design of `setMetadata`\n\t\treturn plots[_tokenId].size != 0;\n\t}\n\n\t/**\n\t * @inheritdoc ERC721Upgradeable\n\t *\n\t * @dev If land descriptor is set on the contract, uses it to render the URI\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n\t\t// if land descriptor is set on the contract\n\t\tif(landDescriptor != address(0)) {\n\t\t\t// verify token exists\n\t\t\trequire(exists(_tokenId), \"token doesn't exist\");\n\n\t\t\t// try using it to render the token URI\n\t\t\tstring memory _tokenURI = LandDescriptor(landDescriptor).tokenURI(_tokenId);\n\n\t\t\t// if descriptor rendered non-empty URI\n\t\t\tif(bytes(_tokenURI).length > 0) {\n\t\t\t\t// return is a result\n\t\t\t\treturn _tokenURI;\n\t\t\t}\n\t\t}\n\n\t\t// otherwise fallback to the default logic\n\t\treturn super.tokenURI(_tokenId);\n\t}\n\n\t/**\n\t * @dev Sets/updates token metadata on-chain; same metadata struct can be then\n\t *      read back using `getMetadata()` function, or it can be converted to\n\t *      `PlotView` using `viewMetadata()` function\n\t *\n\t * @dev The metadata supplied is validated to satisfy (regionId, x, y) uniqueness;\n\t *      non-intersection of the sites coordinates within a plot is guaranteed by the\n\t *      internal land structure generator algorithm embedded into the `viewMetadata()`\n\t *\n\t * @dev Metadata for non-existing tokens can be set and updated unlimited\n\t *      amount of times without any restrictions (except the constraints above)\n\t * @dev Metadata for an existing token can only be set, it cannot be updated\n\t *      (`setMetadata` will throw if metadata already exists)\n\t *\n\t * @dev Requires executor to have ROLE_METADATA_PROVIDER permission\n\t *\n\t * @param _tokenId token ID to set/updated the metadata for\n\t * @param _plot token metadata to be set for the token ID\n\t */\n\tfunction setMetadata(uint256 _tokenId, LandLib.PlotStore memory _plot) public virtual override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_METADATA_PROVIDER), \"access denied\");\n\n\t\t// validate the metadata\n\t\t// supported version(s): 1\n\t\trequire(_plot.version == 1, \"unsupported metadata version\");\n\t\t// version 1 supports only regions in range [0, 7]\n\t\trequire(_plot.regionId <= 7, \"unsupported region\");\n\t\t// 24x24 grid can contain up to 56 resource sites,\n\t\t// while current maximum is 27 sites (for tier 5)\n\t\trequire(_plot.size >= 24, \"too small\");\n\t\t// version 1 supports only landmarks of types in range [0, 7]\n\t\trequire(_plot.landmarkTypeId <= 7, \"unsupported landmark type\");\n\n\t\t// metadata cannot be updated for existing token\n\t\trequire(!exists(_tokenId), \"token exists\");\n\n\t\t// ensure the location of the plot is not yet taken\n\t\trequire(plotLocations[_plot.loc()] == 0, \"spot taken\");\n\n\t\t// register the plot location\n\t\tplotLocations[_plot.loc()] = _tokenId;\n\n\t\t// write metadata into the storage\n\t\tplots[_tokenId] = _plot;\n\n\t\t// emit an event\n\t\temit MetadataUpdated(msg.sender, _tokenId, _plot);\n\t}\n\n\t/**\n\t * @dev Restricted access function to remove token metadata\n\t *\n\t * @dev Requires executor to have ROLE_METADATA_PROVIDER permission\n\t *\n\t * @param _tokenId token ID to remove metadata for\n\t */\n\tfunction removeMetadata(uint256 _tokenId) public virtual override {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_METADATA_PROVIDER), \"access denied\");\n\n\t\t// remove token metadata - delegate to `_removeMetadata`\n\t\t_removeMetadata(_tokenId);\n\t}\n\n\t/**\n\t * @dev Internal helper function to remove token metadata\n\t *\n\t * @param _tokenId token ID to remove metadata for\n\t */\n\tfunction _removeMetadata(uint256 _tokenId) internal virtual {\n\t\t// verify token doesn't exist\n\t\trequire(!exists(_tokenId), \"token exists\");\n\n\t\t// read the plot - it will be logged into event anyway\n\t\tLandLib.PlotStore memory _plot = plots[_tokenId];\n\n\t\t// erase token metadata\n\t\tdelete plots[_tokenId];\n\n\t\t// unregister the plot location\n\t\tdelete plotLocations[_plot.loc()];\n\n\t\t// emit an event first - to log the data which will be deleted\n\t\temit MetadataRemoved(msg.sender, _tokenId, _plot);\n\t}\n\n\t/**\n\t * @dev Restricted access function to mint the token\n\t *      and assign the metadata supplied\n\t *\n\t * @dev Creates new token with the token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *      Consider minting with `safeMint` (and setting metadata before),\n\t *      for the \"safe mint\" like behavior\n\t *\n\t * @dev Requires executor to have ROLE_METADATA_PROVIDER\n\t *      and ROLE_TOKEN_CREATOR permissions\n\t *\n\t * @param _to an address to mint token to\n\t * @param _tokenId token ID to mint and set metadata for\n\t * @param _plot token metadata to be set for the token ID\n\t */\n\tfunction mintWithMetadata(address _to, uint256 _tokenId, LandLib.PlotStore memory _plot) public virtual override {\n\t\t// simply create token metadata and mint it in the correct order:\n\n\t\t// 1. set the token metadata via `setMetadata`\n\t\tsetMetadata(_tokenId, _plot);\n\n\t\t// 2. mint the token via `mint`\n\t\tmint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc ImmutableMintableERC721\n\t *\n\t * @dev Restricted access function to mint the token  and assign\n\t *      the metadata packed into the IMX `mintingBlob` bytes array\n\t *\n\t * @dev Creates new token with the token ID specified\n\t *      and assigns an ownership `_to` for this token\n\t *\n\t * @dev Unsafe: doesn't execute `onERC721Received` on the receiver.\n\t *\n\t * @dev Requires executor to have ROLE_METADATA_PROVIDER\n\t *      and ROLE_TOKEN_CREATOR permissions\n\t *\n\t * @param _to an address to mint token to\n\t * @param _quantity rudimentary (ERC20 amount of tokens to mint) equal to one,\n\t *      implementation MUST revert if it not equal to one\n\t * @param _mintingBlob blob containing the ID of the NFT and its metadata as\n\t *      `{tokenId}:{metadata}` string, where `tokenId` is encoded as decimal string,\n\t *      and metadata can be anything, but most likely is also encoded as decimal string\n\t */\n\tfunction mintFor(address _to, uint256 _quantity, bytes calldata _mintingBlob) public virtual override {\n\t\t// ensure quantity is equal to one (rudimentary ERC20 amount of tokens to mint)\n\t\trequire(_quantity == 1, \"quantity must be equal to one\");\n\n\t\t// parse the `_mintingBlob` and extract the tokenId and metadata from it\n\t\t// note: `LandBlobLib.parseMintingBlob` works faster than IMX `Minting.split`\n\t\t(uint256 _tokenId, uint256 _metadata) = LandBlobLib.parseMintingBlob(_mintingBlob);\n\n\t\t// delegate to `mintWithMetadata`\n\t\tmintWithMetadata(_to, _tokenId, _metadata.unpack());\n\t}\n\n\t/**\n\t * @dev Restricted access function to set/update/remove the LandDescriptor\n\t *      implementation address; use zero address to remove the descriptor\n\t *\n\t * @dev Requires executor to have ROLE_URI_MANAGER permission\n\t *\n\t * @param _landDescriptor new LandDescriptor implementation address, or zero\n\t */\n\tfunction setLandDescriptor(address _landDescriptor) public virtual {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_URI_MANAGER), \"access denied\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit LandDescriptorUpdated(msg.sender, landDescriptor, _landDescriptor);\n\n\t\t// update the implementation address (can also remove it by setting to zero)\n\t\tlandDescriptor = _landDescriptor;\n\t}\n\n\t/**\n\t * @inheritdoc UpgradeableERC721\n\t *\n\t * @dev Overridden function is required to ensure\n\t *      - zero token ID is not minted\n\t *      - token Metadata exists when minting\n\t */\n\tfunction _mint(address _to, uint256 _tokenId) internal virtual override {\n\t\t// zero token ID is invalid (see `plotLocations` mapping)\n\t\trequire(_tokenId != 0, \"zero ID\");\n\n\t\t// verify the metadata for the token already exists\n\t\trequire(hasMetadata(_tokenId), \"no metadata\");\n\n\t\t// mint the token - delegate to `super._mint`\n\t\tsuper._mint(_to, _tokenId);\n\t}\n\n\t/**\n\t * @inheritdoc UpgradeableERC721\n\t *\n\t * @dev Overridden function is required to erase token Metadata when burning\n\t */\n\tfunction _burn(uint256 _tokenId) internal virtual override {\n\t\t// burn the token itself - delegate to `super._burn`\n\t\tsuper._burn(_tokenId);\n\n\t\t// remove token metadata - delegate to `_removeMetadata`\n\t\t_removeMetadata(_tokenId);\n\t}\n}\n"
    },
    "contracts/interfaces/ImmutableSpec.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Immutable X Mintable Specification\n *\n * @notice Interfaces supporting IMX integration:\n *      - ImmutableMintableERC20: @imtbl/imx-contracts/contracts/IMintable.sol\n *      - ImmutableMintableERC721: @imtbl/imx-contracts/contracts/IMintable.sol\n *\n * @dev See https://docs.x.immutable.com/docs/minting-assets-1\n * @dev See https://docs.x.immutable.com/docs/partner-nft-minting-setup\n *\n * @author Basil Gorin\n */\n\n/**\n * @dev IMX Mintable interface, enables Layer 2 minting in IMX,\n *      see https://docs.x.immutable.com/docs/minting-assets-1\n *\n * @dev See @imtbl/imx-contracts/contracts/IMintable.sol\n */\ninterface ImmutableMintableERC20 {\n\t/**\n\t * @dev Mints ERC20 tokens\n\t *\n\t * @param to address to mint tokens to\n\t * @param amount amount of tokens to mint\n\t * @param mintingBlob [optional] data structure supplied\n\t */\n\tfunction mintFor(address to, uint256 amount, bytes calldata mintingBlob) external;\n}\n\n/**\n * @dev IMX Mintable interface, enables Layer 2 minting in IMX,\n *      see https://docs.x.immutable.com/docs/minting-assets-1\n *      see https://docs.x.immutable.com/docs/asset-minting\n *\n * @dev See @imtbl/imx-contracts/contracts/IMintable.sol\n */\ninterface ImmutableMintableERC721 {\n\t/**\n\t * @dev Mints an NFT\n\t *\n\t * @param to address to mint NFT to\n\t * @param quantity rudimentary (ERC20 amount of tokens to mint) equal to one,\n\t *      implementation MUST revert if it not equal to one\n\t * @param mintingBlob blob containing the ID of the NFT and its metadata as\n\t *      `{tokenId}:{metadata}` string, where `tokenId` is encoded as decimal string,\n\t *      and metadata can be anything, but most likely is also encoded as decimal string\n\t */\n\tfunction mintFor(address to, uint256 quantity, bytes calldata mintingBlob) external;\n}\n"
    },
    "contracts/lib/LandBlobLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\n/**\n * @title Land Blob Library\n *\n * @dev A library to support `mintingBlob` parsing supplied into `mintFor`\n *      NFT minting function executed when withdrawing an NFT from L2 into L1\n *\n * @dev The blob supplied is a bytes string having the `{tokenId}:{metadata}`\n *      format which needs to be parsed more effectively than `imx-contracts`\n *      does currently\n *\n * @dev This library implements the `parseMintingBlob` function which\n *      iterates over the blob only once and extracts `tokenId` and `metadata` from it\n *\n * @author Basil Gorin\n */\nlibrary LandBlobLib {\n\t/**\n\t * @dev Simplified version of StringUtils.atoi to convert a bytes string\n\t *      to unsigned integer using ten as a base\n\t * @dev Stops on invalid input (wrong character for base ten) and returns\n\t *      the position within a string where the wrong character was encountered\n\t *\n\t * @dev Throws if input string contains a number bigger than uint256\n\t *\n\t * @param a numeric string to convert\n\t * @param offset an index to start parsing from, set to zero to parse from the beginning\n\t * @return i a number representing given string\n\t * @return p an index where the conversion stopped\n\t */\n\tfunction atoi(bytes calldata a, uint8 offset) internal pure returns (uint256 i, uint8 p) {\n\t\t// skip wrong characters in the beginning of the string if any\n\t\tfor(p = offset; p < a.length; p++) {\n\t\t\t// check if digit is valid and meets the base 10\n\t\t\tif(isDecimal(a[p])) {\n\t\t\t\t// we've found decimal character, skipping stops\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// if there weren't any digits found\n\t\tif(p == a.length) {\n\t\t\t// just return a zero result\n\t\t\treturn (0, offset);\n\t\t}\n\n\t\t// iterate over the rest of the string (bytes buffer)\n\t\tfor(; p < a.length; p++) {\n\t\t\t// check if digit is valid and meets the base 10\n\t\t\tif(!isDecimal(a[p])) {\n\t\t\t\t// we've found bad character, parsing stops\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// move to the next digit slot\n\t\t\ti *= 10;\n\n\t\t\t// extract the digit and add it to the result\n\t\t\ti += uint8(a[p]) - 0x30;\n\t\t}\n\n\t\t// return the result\n\t\treturn (i, p);\n\t}\n\n\t/**\n\t * @dev Checks if the byte1 represented character is a decimal number or not (base 10)\n\t *\n\t * @return true if the character represents a decimal number\n\t */\n\tfunction isDecimal(bytes1 char) private pure returns (bool) {\n\t\treturn uint8(char) >= 0x30 && uint8(char) < 0x3A;\n\t}\n\n\t/**\n\t * @dev Parses a bytes string formatted as `{tokenId}:{metadata}`, containing `tokenId`\n\t *      and `metadata` encoded as decimal strings\n\t *\n\t * @dev Throws if either `tokenId` or `metadata` strings are numbers bigger than uint256\n\t * @dev Doesn't validate the `{tokenId}:{metadata}` format, would extract any first 2 decimal\n\t *      numbers split with any separator, for example (see also land_blob_lib_test.js):\n\t *      `{123}:{467}` => (123, 467)\n\t *      `123:467` => (123, 467)\n\t *      `123{}467` => (123, 467)\n\t *      `b123abc467a` => (123, 467)\n\t *      `b123abc467a8910` => (123, 467)\n\t *      ` 123 467 ` => (123, 467)\n\t *      `123\\n467` => (123, 467)\n\t *      `[123,467]` => (123, 467)\n\t *      `[123; 467]` => (123, 467)\n\t *      `(123, 467)` => (123, 467)\n\t *      `(123, 467, 8910)` => (123, 467)\n\t *      `{123.467}` => (123, 467)\n\t *      `{123.467.8910}` => (123, 467)\n\t *      `123` => (123, 0)\n\t *      `abc123` => (123, 0)\n\t *      `123abc` => (123, 0)\n\t *      `{123}` => (123, 0)\n\t *      `{123:}` => (123, 0)\n\t *      `{:123}` => (123, 0)\n\t *      `{,123}` => (123, 0)\n\t *      `\\n123` => (123, 0)\n\t *      `{123,\\n}` => (123, 0)\n\t *      `{\\n,123}` => (123, 0)\n\t *      `(123, 0)` => (123, 0)\n\t *      `0:123` => (0, 123)\n\t *      `0:123:467` => (0, 123)\n\t *      `0; 123` => (0, 123)\n\t *      `(0, 123)` => (0, 123)\n\t *      `(0, 123, 467)` => (0, 123)\n\t *      `0,123` => (0, 123)\n\t *      `0,123,467` => (0, 123)\n\t *      `0.123` => (0, 123)\n\t *      `0.123.467` => (0, 123)\n\t *      `` => throws (no tokenId found)\n\t *      `abc` => throws (no tokenId found)\n\t *      `{}` => throws (no tokenId found)\n\t *      `0` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `{0}` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `{0}:{0}` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `{0}:` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `(0, 0, 123)` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `:0` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `\\n0` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `\\n0\\n0\\n123` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *\n\t * @param mintingBlob bytes string input formatted as `{tokenId}:{metadata}`\n\t * @return tokenId extracted `tokenId` as an integer\n\t * @return metadata extracted `metadata` as an integer\n\t */\n\tfunction parseMintingBlob(bytes calldata mintingBlob) internal pure returns (uint256 tokenId, uint256 metadata) {\n\t\t// indexes where the string parsing stops (where `atoi` reaches the \"}\")\n\t\tuint8 p1;\n\t\tuint8 p2;\n\n\t\t// read the `tokenId` value\n\t\t(tokenId, p1) = atoi(mintingBlob, 0);\n\n\t\t// ensure the parsed string has the `tokenId` value set\n\t\trequire(p1 > 0, \"no tokenId found\");\n\n\t\t// read the `metadata` value\n\t\t(metadata, p2) = atoi(mintingBlob, p1);\n\n\t\t// return the result\n\t\treturn (tokenId, metadata);\n\t}\n}\n"
    },
    "contracts/mocks/LandBlobLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/LandBlobLib.sol\";\n\n/**\n * @title Land Blob Library Mock\n *\n * @notice Used to test Land Blob Library, by exposing its internal functions\n *\n * @author Basil Gorin\n */\ncontract LandBlobLibMock {\n\t/**\n\t * @dev Simplified version of StringUtils.atoi to convert a bytes string\n\t *      to unsigned integer using ten as a base\n\t * @dev Stops on invalid input (wrong character for base ten) and returns\n\t *      the position within a string where the wrong character was encountered\n\t *\n\t * @dev Throws if input string contains a number bigger than uint256\n\t *\n\t * @param a numeric string to convert\n\t * @param offset an index to start parsing from, set to zero to parse from the beginning\n\t * @return i a number representing given string\n\t * @return p an index where the conversion stopped\n\t */\n\tfunction atoi(bytes calldata a, uint8 offset) public pure returns (uint256 i, uint8 p) {\n\t\t// delegate to internal impl\n\t\treturn LandBlobLib.atoi(a, offset);\n\t}\n\n\t/**\n\t * @dev Parses a bytes string formatted as `{tokenId}:{metadata}`, containing `tokenId`\n\t *      and `metadata` encoded as decimal strings\n\t *\n\t * @dev Throws if either `tokenId` or `metadata` strings are numbers bigger than uint256\n\t * @dev Doesn't validate the `{tokenId}:{metadata}` format, would extract any first 2 decimal\n\t *      numbers split with any separator, for example (see also land_blob_lib_test.js):\n\t *      `{123}:{467}` => (123, 467)\n\t *      `123:467` => (123, 467)\n\t *      `123{}467` => (123, 467)\n\t *      `b123abc467a` => (123, 467)\n\t *      `b123abc467a8910` => (123, 467)\n\t *      ` 123 467 ` => (123, 467)\n\t *      `123\\n467` => (123, 467)\n\t *      `[123,467]` => (123, 467)\n\t *      `[123; 467]` => (123, 467)\n\t *      `(123, 467)` => (123, 467)\n\t *      `(123, 467, 8910)` => (123, 467)\n\t *      `{123.467}` => (123, 467)\n\t *      `{123.467.8910}` => (123, 467)\n\t *      `123` => (123, 0)\n\t *      `abc123` => (123, 0)\n\t *      `123abc` => (123, 0)\n\t *      `{123}` => (123, 0)\n\t *      `{123:}` => (123, 0)\n\t *      `{:123}` => (123, 0)\n\t *      `{,123}` => (123, 0)\n\t *      `\\n123` => (123, 0)\n\t *      `{123,\\n}` => (123, 0)\n\t *      `{\\n,123}` => (123, 0)\n\t *      `(123, 0)` => (123, 0)\n\t *      `0:123` => (0, 123)\n\t *      `0:123:467` => (0, 123)\n\t *      `0; 123` => (0, 123)\n\t *      `(0, 123)` => (0, 123)\n\t *      `(0, 123, 467)` => (0, 123)\n\t *      `0,123` => (0, 123)\n\t *      `0,123,467` => (0, 123)\n\t *      `0.123` => (0, 123)\n\t *      `0.123.467` => (0, 123)\n\t *      `` => throws (no tokenId found)\n\t *      `abc` => throws (no tokenId found)\n\t *      `{}` => throws (no tokenId found)\n\t *      `0` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `{0}` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `{0}:{0}` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `{0}:` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `(0, 0, 123)` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `:0` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `\\n0` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *      `\\n0\\n0\\n123` => (0, 0) - note: doesn't throw, even though zero tokenId is not valid\n\t *\n\t * @param mintingBlob bytes string input formatted as `{tokenId}:{metadata}`\n\t * @return tokenId extracted `tokenId` as an integer\n\t * @return metadata extracted `metadata` as an integer\n\t */\n\tfunction parseMintingBlob(bytes calldata mintingBlob) public pure returns (uint256 tokenId, uint256 metadata) {\n\t\t// delegate to internal impl\n\t\treturn LandBlobLib.parseMintingBlob(mintingBlob);\n\t}\n}\n"
    },
    "contracts/mocks/LandLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/LandLib.sol\";\n\n/**\n * @title Land Library Mock\n *\n * @notice Used to test Land Library, by exposing its internal functions\n *\n * @author Basil Gorin\n */\ncontract LandLibMock {\n\t/**\n\t * @dev Tightly packs `PlotStore` data struct into uint256 representation\n\t *\n\t * @param store `PlotStore` data struct to pack\n\t * @return packed `PlotStore` data struct packed into uint256\n\t */\n\tfunction pack(LandLib.PlotStore memory store) public pure returns (uint256 packed) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.pack(store);\n\t}\n\n\t/**\n\t * @dev Unpacks `PlotStore` data struct from uint256 representation\n\t *\n\t * @param packed uint256 packed `PlotStore` data struct\n\t * @return store unpacked `PlotStore` data struct\n\t */\n\tfunction unpack(uint256 packed) public pure returns (LandLib.PlotStore memory store) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.unpack(packed);\n\t}\n\n\t/**\n\t * @dev Expands `PlotStore` data struct into a `PlotView` view struct\n\t *\n\t * @dev Derives internal land structure (resource sites the plot has)\n\t *      from Number of Element/Fuel Sites, Plot Size, and Seed;\n\t *      Generator Version is not currently used\n\t *\n\t * @param store on-chain `PlotStore` data structure to expand\n\t * @return `PlotView` view struct, expanded from the on-chain data\n\t */\n\tfunction plotView(LandLib.PlotStore memory store) public pure returns (LandLib.PlotView memory) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.plotView(store);\n\t}\n\n\t/**\n\t * @dev Based on the random seed, tier ID, and plot size, determines the\n\t *      internal land structure (resource sites the plot has)\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @param seed random seed to consume and derive the internal structure\n\t * @param elementSites number of element sites plot has\n\t * @param fuelSites number of fuel sites plot has\n\t * @param gridSize plot size `N` of the land plot to derive internal structure for\n\t * @param siteSize implied size `n` of the resource sites\n\t * @return sites randomized array of resource sites\n\t */\n\tfunction getResourceSites(\n\t\tuint256 seed,\n\t\tuint8 elementSites,\n\t\tuint8 fuelSites,\n\t\tuint16 gridSize,\n\t\tuint8 siteSize\n\t) public pure returns (LandLib.Site[] memory sites) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.getResourceSites(seed, elementSites, fuelSites, gridSize, siteSize);\n\t}\n\n\t/**\n\t * @dev Based on the random seed and tier ID determines the landmark type of the plot.\n\t *      Random seed is consumed for tiers 3 and 4 to randomly determine one of three\n\t *      possible landmark types.\n\t *      Tier 5 has its landmark type predefined (arena), lower tiers don't have a landmark.\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @param seed random seed to consume and derive the landmark type based on\n\t * @param tierId tier ID of the land plot\n\t * @return landmarkTypeId landmark type defined by its ID\n\t */\n\tfunction getLandmark(uint256 seed, uint8 tierId) public pure returns (uint8 landmarkTypeId) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.getLandmark(seed, tierId);\n\t}\n\n\t/**\n\t * @dev Derives an array of integers with no duplicates from the random seed;\n\t *      each element in the array is within [0, size) bounds and represents\n\t *      a two-dimensional Cartesian coordinate point (x, y) presented as one-dimensional\n\t *\n\t * @dev Function works in a deterministic way and derives the same data\n\t *      for the same inputs; the term \"random\" in comments means \"pseudo-random\"\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive coordinates from\n\t * @param length number of elements to generate\n\t * @param size defines array element bounds [0, size)\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t * @return coords the resulting array of length `n` with random non-repeating elements\n\t *      in [0, size) range\n\t */\n\tfunction getCoords(\n\t\tuint256 seed,\n\t\tuint8 length,\n\t\tuint16 size\n\t) public pure returns (uint256 nextSeed, uint16[] memory coords) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.getCoords(seed, length, size);\n\t}\n\n\t/**\n\t * @dev Based on the random seed, generates next random seed, and a random value\n\t *      not lower than given `offset` value and able to have `options` different\n\t *      possible values\n\t *\n\t * @dev The input seed is considered to be already used to derive some random value\n\t *      from it, therefore the function derives a new one by hashing the previous one\n\t *      before generating the random value; the output seed is \"used\" - output random\n\t *      value is derived from it\n\t *\n\t * @param seed random seed to consume and derive next random value from\n\t * @param offset the minimum possible output\n\t * @param options number of different possible values to output\n\t * @return nextSeed next pseudo-random \"used\" seed\n\t * @return rndVal random value in the [offset, offset + options) range\n\t */\n\tfunction nextRndUint16(\n\t\tuint256 seed,\n\t\tuint16 offset,\n\t\tuint16 options\n\t) public pure returns (\n\t\tuint256 nextSeed,\n\t\tuint16 rndVal\n\t) {\n\t\t// delegate to internal impl\n\t\treturn LandLib.nextRndUint16(seed, offset, options);\n\t}\n\n\t/**\n\t * @dev Sorts an array of integers using quick sort algorithm\n\t *\n\t * @dev Quick sort recursive implementation\n\t *      Source:   https://gist.github.com/subhodi/b3b86cc13ad2636420963e692a4d896f\n\t *      See also: https://www.geeksforgeeks.org/quick-sort/\n\t *\n\t * @param arr an array to sort\n\t */\n\tfunction sort(uint16[] memory arr) public pure returns(uint16[] memory) {\n\t\t// delegate to internal impl\n\t\tLandLib.sort(arr);\n\n\t\t// return the modified result\n\t\treturn arr;\n\t}\n\n}\n"
    },
    "contracts/lib/LandSvgLib.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"./LandLib.sol\";\nimport \"base64-sol/base64.sol\";\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\nimport \"prb-math/contracts/PRBMathUD60x18.sol\";\n\n/**\n * @title Land SVG Library\n *\n * @notice Provide functions to generate SVG image representation of the LandERC721, and other\n *      auxiliary functions to construct token metadata JSON, and encode it into base64 format.\n *\n * @dev The metadata format, returned by `constructTokenURI` function conforms with the official\n *\tERC721 metadata standard.\n *\n * @dev There are basically 3 components of the metadata schema, the name, description and the image itself.\n *\teach of them have it's generating functions, `generateLandName`, `generateLandDescription` and `_generateSVGImage`.\n *\n * @dev The output of `_generateSVGImage` will be encoded as Base64 so that the browser can interpret it, as well as the\n *\tentire output of `constructTokenURI`.\n *\n * @dev LandDescriptor should call `constructTokenURI` in order to get the encoded ERC721 metadata.\n *\n * @author Pedro Bergamini, Yuri Fernandes, Estevan Wisoczynski\n */\nlibrary LandSvgLib {\n\tusing Strings for uint256;\n\tusing PRBMathUD60x18 for uint256;\n\n\t/**\n\t * @dev Generate the Land SVG image.\n\t *\n\t * @param _gridSize The size of the grid\n\t * @param _tierId PlotView.tierId land tier id\n\t * @param _landmarkTypeId landmark type id\n\t * @param _sites array of LandLib.Site\n\t * @return Land SVG image\n\t */\n\tfunction _generateSVGImage(\n\t\tuint16 _gridSize, \n\t\tuint8 _tierId, \n\t\tuint8 _landmarkTypeId,\n\t\tLandLib.Site[] memory _sites\n\t) private pure returns (string memory) {\n\t\t// Multiply by 3 to get number of grid squares = dimension of the isomorphic grid size\n\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"<svg height='\",\n\t\t\t\tuint256(_gridSize * 3 + 6).toString(),\n\t\t\t\t\"' width='\",\n\t\t\t\tuint256(_gridSize * 3).toString(),\n\t\t\t\t\"' stroke-width='2' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\t\"<rect rx='5%' ry='5%' width='100%' height='99%' fill='url(#BOARD_BOTTOM_BORDER_COLOR_TIER_\",\n\t\t\t\tuint256(_tierId).toString(),\n\t\t\t\t\")' stroke='none'/>\",\n\t\t\t\t\"<svg height='97.6%' width='100%' stroke-width='2' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\t_generateLandBoard(_gridSize, _tierId, _landmarkTypeId, _sites), // This line should be replaced in the loop\n\t\t\t\t\"</svg>\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the site base svg array component, used to represent\n\t *      a site inside the land board.\n\t *\n\t * @param _x Sites.x position\n\t * @param _y Sites.y position\n\t * @param _typeId Sites.typeId\n\t * @return The base SVG element for the sites\n\t */\n\tfunction _siteBaseSvg(uint16 _x, uint16 _y, uint8 _typeId) private pure returns (string memory) {\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"<svg x='\", \n\t\t\t\tuint256(_x).toString(), \n\t\t\t\t\"' y='\", \n\t\t\t\tuint256(_y).toString(),\n\t\t\t\t\"' width='6' height='6' xmlns='http://www.w3.org/2000/svg'><use href='#SITE_TYPE_\",\n\t\t\t\tuint256(_typeId).toString(),\n\t\t\t\t\"' /></svg>\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the site base svg array component, used to represent\n\t *      a landmark inside the land board.\n\t *\n\t * @param _gridSize The size of the grid\n\t * @param _landmarkTypeId landmark type defined by its ID\n\t * @return Concatenation of the landmark SVG component to be added the board SVG\n\t */\n\tfunction _generateLandmarkSvg(uint16 _gridSize, uint8 _landmarkTypeId) private pure returns (string memory) {\n\t\tuint256 landmarkPos = uint256(_gridSize - 2).fromUint().div(uint256(2).fromUint()).mul(uint256(3).fromUint());\n\n\t\tstring memory landmarkFloatX;\n\t\tstring memory landmarkFloatY;\n\t\tif (_gridSize % 2 == 0) {\n\t\t\tlandmarkFloatX = landmarkPos.toUint().toString();\n\t\t\tlandmarkFloatY = (landmarkPos.toUint() - 3).toString();\n\t\t} else {\n\t\t\tlandmarkFloatX = (landmarkPos.ceil().toUint() + 1).toString();\n\t\t\tlandmarkFloatY = (landmarkPos.floor().toUint() - 1).toString();\n\t\t}\n\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\t\"<svg x='\",\n\t\t\t\tlandmarkFloatX,\n\t\t\t\t\"' y='\",\n\t\t\t\tlandmarkFloatY,\n\t\t\t\t\"' width='12' height='12' xmlns='http://www.w3.org/2000/svg'><use href='#LANDMARK_TYPE_\",\n\t\t\t\tuint256(_landmarkTypeId).toString(),\n\t\t\t\t\"'/></svg>\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the land board base svg array component, which has its color changed\n\t *      later in other functions.\n\t *\n\t * @param _gridSize The size of the grid\n\t * @param _tierId PlotView.tierId land tier id\n\t * @param _landmarkTypeId landmark type id\n\t * @param _sites array of LandLib.Site\n\t * @return Array of board SVG component parts\n\t */\n\tfunction _landBoardArray(\n\t\tuint16 _gridSize, \n\t\tuint8 _tierId, \n\t\tuint8 _landmarkTypeId, \n\t\tLandLib.Site[] memory _sites\n\t) private pure returns (string[170] memory) {\n\t\tuint256 scaledGridSize = uint256(_gridSize).fromUint().div(uint256(2).fromUint()).mul(uint256(3).fromUint());\n\t\tstring memory scaledGridSizeString = string(\n\t\t\tabi.encodePacked(\n\t\t\t\tscaledGridSize.toUint().toString(),\n\t\t\t\t\".\",\n\t\t\t\t(scaledGridSize.frac()/1e16).toString()\n\t\t\t)\n\t\t);\n\t\treturn [\n\t\t\t\"<defs><symbol id='SITE_TYPE_1' width='6' height='6'>\", // Site Carbon\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 14 14' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='12' height='12' fill='url(#site-type-1)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='site-type-1' x1='13.12' y1='1' x2='1.12' y2='13' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_2' width='6' height='6'>\", // Site Silicon\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129011)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129011' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#CBE2FF'/><stop offset='1' stop-color='#EFEFEF'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_3' width='6' height='6'>\", // Site Hydrogen\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1320_145814)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1320_145814' x1='11.12' y1='1' x2='-0.862058' y2='7.11845' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#8CD4D9'/><stop offset='1' stop-color='#598FA6'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_4' width='6' height='6'>\", // Site Crypton\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129013)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129013' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop offset='1' stop-color='#52FF00'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_5' width='6' height='6'>\", // Site Hyperion\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129017)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129017' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#31F27F'/><stop offset='0.296875' stop-color='#F4BE86'/><stop offset='0.578125' stop-color='#B26FD2'/>\",\n\t\t\t\"<stop offset='0.734375' stop-color='#7F70D2'/><stop offset='1' stop-color='#8278F2'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='SITE_TYPE_6' width='6' height='6'>\",\n\t\t\t\"<svg width='6' height='6' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\", // Site Solon\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_1321_129015)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_1321_129015' x1='11.12' y1='1' x2='1.11999' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='white'/><stop offset='0.544585' stop-color='#FFD600'/><stop offset='1' stop-color='#FF9900'/>\",\n\t\t\t\"</linearGradient></defs></svg></symbol>\",\n\t\t\t\"<linearGradient id='BOARD_BOTTOM_BORDER_COLOR_TIER_5' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#BE13AE'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_4' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#1F7460'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_3' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#6124AE'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_2' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#5350AA'/></linearGradient><linearGradient\",\n\t\t\t\" id='BOARD_BOTTOM_BORDER_COLOR_TIER_1' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#2C2B67'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_5' x1='100%' y1='0' x2='100%' y2='100%'\", \n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop offset='0.130208' stop-color='#EFD700'/>\",\n\t\t\t\"<stop offset='0.6875' stop-color='#FF57EE'/><stop offset='1' stop-color='#9A24EC'/>\",\n\t\t\t\"</linearGradient><linearGradient id='GRADIENT_BOARD_TIER_4' x1='50%' y1='100%' x2='50%' y2='0'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#239378'/><stop offset='1' stop-color='#41E23E'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_3' x1='50%' y1='100%' x2='50%' y2='0'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#812DED'/><stop offset='1' stop-color='#F100D9'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_2' x1='50%' y1='0' x2='50%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#7DD6F2'/><stop offset='1' stop-color='#625EDC'/></linearGradient>\",\n\t\t\t\"<linearGradient id='GRADIENT_BOARD_TIER_1' x1='50%' y1='0' x2='50%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#4C44A0'/><stop offset='1' stop-color='#2F2C83'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_5' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#D2FFD9'/><stop offset='1' stop-color='#F32BE1'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_4' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_3' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_2' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<linearGradient id='ROUNDED_BORDER_TIER_1' x1='100%' y1='16.6%' x2='100%' y2='100%'\",\n\t\t\t\" gradientUnits='userSpaceOnUse' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<stop stop-color='#fff' stop-opacity='0.38'/><stop offset='1' stop-color='#fff'\",\n\t\t\t\" stop-opacity='0.08'/></linearGradient>\",\n\t\t\t\"<pattern id='smallGrid' width='3' height='3' patternUnits='userSpaceOnUse' patternTransform='rotate(45 \",\n\t\t\tstring(abi.encodePacked(scaledGridSizeString, \" \", scaledGridSizeString)),\n\t\t\t\")'><path d='M 3 0 L 0 0 0 3' fill='none' stroke-width='0.3%' stroke='#130A2A' stroke-opacity='0.2' />\",\n\t\t\t\"</pattern><symbol id='LANDMARK_TYPE_1' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 14 14' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='12' height='12' fill='url(#paint0_linear_2371_558677)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.72' y='4.59998' width='4.8' height='4.8' fill='url(#paint1_linear_2371_558677)'/>\",\n\t\t\t\"<rect x='4.72' y='4.59998' width='4.8' height='4.8' fill='white'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558677' x1='13.12' y1='1' x2='1.12' y2='13' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558677' x1='9.52' y1='4.59998' x2='4.72' y2='9.39998' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_2' width='12' height='12'><svg width='12' height='12'\",\n\t\t\t\" viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558683)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558683)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558683' x1='11.12' y1='1' x2='-0.862058' y2='7.11845'\",\n\t\t\t\" gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#8CD4D9'/><stop offset='1' stop-color='#598FA6'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558683' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_3' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558686)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558686)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558686' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#CBE2FF'/><stop offset='1' stop-color='#EFEFEF'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558686' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_4' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558689)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558689)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558689' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#184B00'/><stop offset='1' stop-color='#52FF00'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558689' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_5' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558695)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558695)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558695' x1='11.12' y1='1' x2='1.12' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#31F27F'/><stop offset='0.296875' stop-color='#F4BE86'/><stop offset='0.578125' stop-color='#B26FD2'/>\",\n\t\t\t\"<stop offset='0.734375' stop-color='#7F70D2'/><stop offset='1' stop-color='#8278F2'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558695' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_6' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2371_558692)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='url(#paint1_linear_2371_558692)'/>\",\n\t\t\t\"<rect x='4.12' y='4' width='4' height='4' fill='white'/>\",\n\t\t\t\"<rect x='3.62' y='3.5' width='5' height='5' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2371_558692' x1='11.12' y1='1' x2='1.11999' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='white'/><stop offset='0.544585' stop-color='#FFD600'/><stop offset='1' stop-color='#FF9900'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2371_558692' x1='8.12' y1='4' x2='4.12' y2='8' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"<symbol id='LANDMARK_TYPE_7' width='12' height='12'>\",\n\t\t\t\"<svg width='12' height='12' viewBox='0 0 12 12' fill='none' xmlns='http://www.w3.org/2000/svg'>\",\n\t\t\t\"<rect x='1.12' y='1' width='10' height='10' fill='url(#paint0_linear_2373_559424)' stroke='white' stroke-opacity='0.5'/>\",\n\t\t\t\"<rect x='3.12' y='3' width='6' height='6' fill='url(#paint1_linear_2373_559424)'/>\",\n\t\t\t\"<rect x='3.12' y='3' width='6' height='6' fill='white'/>\",\n\t\t\t\"<rect x='2.62' y='2.5' width='7' height='7' stroke='black' stroke-opacity='0.1'/>\",\n\t\t\t\"<defs><linearGradient id='paint0_linear_2373_559424' x1='11.12' y1='1' x2='1.11999' y2='11' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#08CE01'/><stop offset='0.171875' stop-color='#CEEF00'/><stop offset='0.34375' stop-color='#51F980'/>\",\n\t\t\t\"<stop offset='0.5' stop-color='#2D51ED'/><stop offset='0.671875' stop-color='#0060F1'/>\",\n\t\t\t\"<stop offset='0.833333' stop-color='#F100D9'/>\",\n\t\t\t\"<stop offset='1' stop-color='#9A24EC'/></linearGradient>\",\n\t\t\t\"<linearGradient id='paint1_linear_2373_559424' x1='9.12' y1='3' x2='3.12' y2='9' gradientUnits='userSpaceOnUse'>\",\n\t\t\t\"<stop stop-color='#565656'/><stop offset='1'/></linearGradient></defs></svg></symbol>\",\n\t\t\t\"</defs><rect width='100%' height='100%' fill='url(#GRADIENT_BOARD_TIER_\",\n\t\t\tuint256(_tierId).toString(), // This line should be replaced in the loop\n\t\t\t\")' stroke='none' rx='5%' ry='5%'/><svg x='\",\n\t\t\t_gridSize % 2 == 0 \n\t\t\t\t? \"-17%' y='-17%' width='117%' height='116.4%' ><g transform='scale(1.34)'\"\n\t\t\t\t\t\" rx='5%' ry='5%' ><rect x='11%' y='11.2%' width='63.6%' height='63.8%\"\n\t\t\t\t: \"-18%' y='-18%' width='117.8%' height='117.8%' ><g transform='scale(1.34)'\"\n\t\t\t\t\t\" rx='5%' ry='5%' ><rect x='11.6%' y='11.6%' width='63.0%' height='63.2%\",\n\t\t\t\"' fill='url(#smallGrid)' stroke='none'  rx='3%' ry='3%' /><g transform='rotate(45 \",\n\t\t\tscaledGridSizeString,\n\t\t\t\" \",\n\t\t\tscaledGridSizeString,\n\t\t\t\")'>\",\n\t\t\t_generateLandmarkSvg(_gridSize, _landmarkTypeId), // Generate LandMark SVG\n\t\t\t_generateSites(_sites), // Generate Sites SVG\n\t\t\t\"</g></g></svg>\",\n\t\t\t\"<rect xmlns='http://www.w3.org/2000/svg' x='0.3' y='0.3'\", \n\t\t\t\" width='99.7%' height='99.7%' fill='none' stroke='url(#ROUNDED_BORDER_TIER_\",\n\t\t\tuint256(_tierId).toString(),\n\t\t\t\")' stroke-width='1' rx='4.5%' ry='4.5%'/></svg>\"\n\t\t];\n\t}\n\n\t/**\n\t* @dev Return the concatenated Land Board SVG string\n\t*\n\t* @param _gridSize The size of the grid\n\t* @param _tierId PlotView.tierId land tier id\n\t* @param _landmarkTypeId landmark type id\n\t* @param _sites array of LandLib.Site\n\t* @return Land Board SVG string\n\t*/\n\tfunction _generateLandBoard(\n\t\tuint16 _gridSize, \n\t\tuint8 _tierId, \n\t\tuint8 _landmarkTypeId, \n\t\tLandLib.Site[] memory _sites\n\t) private pure returns(string memory) {\n\t\tstring[170] memory landBoardArray_ = _landBoardArray(\n\t\t\t_gridSize, \n\t\t\t_tierId, \n\t\t\t_landmarkTypeId, \n\t\t\t_sites\n\t\t);\n\t\tbytes memory landBoardBytes;\n\t\tfor (uint8 i = 0; i < landBoardArray_.length; i++) {\n\t\t\tlandBoardBytes = abi.encodePacked(landBoardBytes, landBoardArray_[i]);\n\t\t}\n\n\t\treturn string(landBoardBytes);\n\t}\n\n\t/**\n\t * @dev Calculates string for the land name based on plot data.\n\t *\n\t * @param _regionId PlotView.regionId\n\t * @param _x PlotView.x coordinate\n\t * @param _y PlotView.y coordinate\n\t * @return SVG name attribute\n\t */\n\tfunction generateLandName(uint8 _regionId, uint16 _x, uint16 _y) internal pure returns (string memory) {\n\t\tstring memory region;\n\t\tif (_regionId == 1) {\n\t\t\tregion = \"Taiga Boreal\";\n\t\t} else if (_regionId == 2) {\n\t\t\tregion = \"Crystal Shores\";\n\t\t} else if (_regionId == 3) {\n\t\t\tregion = \"Shardbluff Labyrinth\";\n\t\t} else if (_regionId == 4) {\n\t\t\tregion = \"Abyssal Basin\";\n\t\t} else if (_regionId == 5) {\n\t\t\tregion = \"Crimson Waste\";\n\t\t} else if (_regionId == 6) {\n\t\t\tregion = \"Brightland Steppes\";\n\t\t} else if (_regionId == 7) {\n\t\t\tregion = \"Halcyon Sea\";\n\t\t} else {\n\t\t\trevert(\"Invalid region ID\");\n\t\t}\n\t\treturn string(\n\t\t\tabi.encodePacked(\n\t\t\t\tregion,\n\t\t\t\t\" (\",\n\t\t\t\tuint256(_x).toString(),\n\t\t\t\t\", \",\n\t\t\t\tuint256(_y).toString(),\n\t\t\t\t\")\"\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Returns the string for the land metadata description.\n\t */\n\tfunction generateLandDescription() internal pure returns (string memory) {\n\t\treturn \"Illuvium Land is a digital piece of real estate in the Illuvium universe that players can mine for fuels through Illuvium Zero. \"\n\t\t\t\"Fuels are ERC-20 tokens that are used in Illuvium games and can be traded on the marketplace. Higher-tiered lands produce more fuel.\"\n\t\t\t\"\\\\n\\\\nLearn more about Illuvium Land at illuvidex.illuvium.io/land.\";\n\t}\n\n\t/**\n\t * @dev Generates each site inside the land svg board with is position and color.\n\t *\n\t * @param _sites Array of plot sites coming from PlotView struct\n\t * @return The sites components for the land SVG\n\t */\n\tfunction _generateSites(LandLib.Site[] memory _sites) private pure returns (string memory) {\n\t\tbytes memory _siteSvgBytes;\n\t\tfor (uint256 i = 0; i < _sites.length; i++) {\n\t\t\t_siteSvgBytes = abi.encodePacked(\n\t\t\t\t_siteSvgBytes,\n\t\t\t\t_siteBaseSvg(\n\t\t\t\t\tconvertToSvgPositionX(_sites[i].x),\n\t\t\t\t\tconvertToSvgPositionY(_sites[i].y),\n\t\t\t\t\t_sites[i].typeId\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn string(_siteSvgBytes);\n\t}\n\n\t/**\n\t * @dev Main function, entry point to generate the complete land svg with all\n\t *      populated sites, correct color, and attach to the JSON metadata file\n\t *      created using Base64 lib.\n\t * @dev Returns the JSON metadata formatted file used by NFT platforms to display\n\t *      the land data.\n\t * @dev Can be updated in the future to change the way land name, description, image\n\t *      and other traits are displayed.\n\t *\n\t * @param _regionId PlotView.regionId\n\t * @param _x PlotView.x coordinate\n\t * @param _y PlotView.y coordinate\n\t * @param _tierId PlotView.tierId land tier id\n\t * @param _gridSize The size of the grid\n\t * @param _landmarkTypeId landmark type defined by its ID\n\t * @param _sites Array of plot sites coming from PlotView struct\n\t */\n\tfunction constructTokenURI(\n\t\tuint8 _regionId,\n\t\tuint16 _x,\n\t\tuint16 _y,\n\t\tuint8 _tierId,\n\t\tuint16 _gridSize,\n\t\tuint8 _landmarkTypeId,\n\t\tLandLib.Site[] memory _sites\n\t) internal pure returns (string memory) {\n\t\tstring memory name = generateLandName(_regionId, _x, _y);\n\t\tstring memory description = generateLandDescription();\n\t\tstring memory image = Base64.encode(\n\t\t\tbytes(\n\t\t\t\t_generateSVGImage(\n\t\t\t\t\t_gridSize, \n\t\t\t\t\t_tierId,\n\t\t\t\t\t_landmarkTypeId,\n\t\t\t\t\t_sites\n\t\t\t\t)\n\t\t\t)\n\t\t);\n\n\t\treturn string(\n\t\t\tabi.encodePacked(\"data:application/json;base64, \", Base64.encode(\n\t\t\t\tbytes(\n\t\t\t\t\tabi.encodePacked('{\"name\":\"',\n\t\t\t\t\tname,\n\t\t\t\t\t'\", \"description\":\"',\n\t\t\t\t\tdescription,\n\t\t\t\t\t'\", \"image\": \"',\n\t\t\t\t\t'data:image/svg+xml;base64,',\n\t\t\t\t\timage,\n\t\t\t\t\t'\"}')\n\t\t\t\t)\n\t\t\t)\n\t\t\t)\n\t\t);\n\t}\n\n\t/**\n\t * @dev Convert site X position to fit into the board.\n\t *\n\t * @param _positionX X coordinate of the site\n\t * @return Transformed X coordinate\n\t */\n\tfunction convertToSvgPositionX(uint16 _positionX) private pure returns (uint16) {\n\t\treturn _positionX * 3;\n\t}\n\n\t/**\n\t * @dev Convert site Y position to fit into the board.\n\t *\n\t * @param _positionY Y coordinate of the site\n\t * @return Transformed Y coordinate\n\t */\n\tfunction convertToSvgPositionY(uint16 _positionY) private pure returns (uint16) {\n\t\treturn _positionY * 3;\n\t}\n}\n"
    },
    "base64-sol/base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.6.0;\n\n/// @title Base64\n/// @author Brecht Devos - <brecht@loopring.org>\n/// @notice Provides functions for encoding/decoding base64\nlibrary Base64 {\n    string internal constant TABLE_ENCODE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    bytes  internal constant TABLE_DECODE = hex\"0000000000000000000000000000000000000000000000000000000000000000\"\n                                            hex\"00000000000000000000003e0000003f3435363738393a3b3c3d000000000000\"\n                                            hex\"00000102030405060708090a0b0c0d0e0f101112131415161718190000000000\"\n                                            hex\"001a1b1c1d1e1f202122232425262728292a2b2c2d2e2f303132330000000000\";\n\n    function encode(bytes memory data) internal pure returns (string memory) {\n        if (data.length == 0) return '';\n\n        // load the table into memory\n        string memory table = TABLE_ENCODE;\n\n        // multiply by 4/3 rounded up\n        uint256 encodedLen = 4 * ((data.length + 2) / 3);\n\n        // add some extra buffer at the end required for the writing\n        string memory result = new string(encodedLen + 32);\n\n        assembly {\n            // set the actual output length\n            mstore(result, encodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 3 bytes at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n                // read 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // write 4 characters\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(shr( 6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1)\n                mstore8(resultPtr, mload(add(tablePtr, and(        input,  0x3F))))\n                resultPtr := add(resultPtr, 1)\n            }\n\n            // padding with '='\n            switch mod(mload(data), 3)\n            case 1 { mstore(sub(resultPtr, 2), shl(240, 0x3d3d)) }\n            case 2 { mstore(sub(resultPtr, 1), shl(248, 0x3d)) }\n        }\n\n        return result;\n    }\n\n    function decode(string memory _data) internal pure returns (bytes memory) {\n        bytes memory data = bytes(_data);\n\n        if (data.length == 0) return new bytes(0);\n        require(data.length % 4 == 0, \"invalid base64 decoder input\");\n\n        // load the table into memory\n        bytes memory table = TABLE_DECODE;\n\n        // every 4 characters represent 3 bytes\n        uint256 decodedLen = (data.length / 4) * 3;\n\n        // add some extra buffer at the end required for the writing\n        bytes memory result = new bytes(decodedLen + 32);\n\n        assembly {\n            // padding with '='\n            let lastBytes := mload(add(data, mload(data)))\n            if eq(and(lastBytes, 0xFF), 0x3d) {\n                decodedLen := sub(decodedLen, 1)\n                if eq(and(lastBytes, 0xFFFF), 0x3d3d) {\n                    decodedLen := sub(decodedLen, 1)\n                }\n            }\n\n            // set the actual output length\n            mstore(result, decodedLen)\n\n            // prepare the lookup table\n            let tablePtr := add(table, 1)\n\n            // input ptr\n            let dataPtr := data\n            let endPtr := add(dataPtr, mload(data))\n\n            // result ptr, jump over length\n            let resultPtr := add(result, 32)\n\n            // run over the input, 4 characters at a time\n            for {} lt(dataPtr, endPtr) {}\n            {\n               // read 4 characters\n               dataPtr := add(dataPtr, 4)\n               let input := mload(dataPtr)\n\n               // write 3 bytes\n               let output := add(\n                   add(\n                       shl(18, and(mload(add(tablePtr, and(shr(24, input), 0xFF))), 0xFF)),\n                       shl(12, and(mload(add(tablePtr, and(shr(16, input), 0xFF))), 0xFF))),\n                   add(\n                       shl( 6, and(mload(add(tablePtr, and(shr( 8, input), 0xFF))), 0xFF)),\n                               and(mload(add(tablePtr, and(        input , 0xFF))), 0xFF)\n                    )\n                )\n                mstore(resultPtr, shl(232, output))\n                resultPtr := add(resultPtr, 3)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "prb-math/contracts/PRBMathUD60x18.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\nimport \"./PRBMath.sol\";\n\n/// @title PRBMathUD60x18\n/// @author Paul Razvan Berg\n/// @notice Smart contract library for advanced fixed-point math that works with uint256 numbers considered to have 18\n/// trailing decimals. We call this number representation unsigned 60.18-decimal fixed-point, since there can be up to 60\n/// digits in the integer part and up to 18 decimals in the fractional part. The numbers are bound by the minimum and the\n/// maximum values permitted by the Solidity type uint256.\nlibrary PRBMathUD60x18 {\n    /// @dev Half the SCALE number.\n    uint256 internal constant HALF_SCALE = 5e17;\n\n    /// @dev log2(e) as an unsigned 60.18-decimal fixed-point number.\n    uint256 internal constant LOG2_E = 1_442695040888963407;\n\n    /// @dev The maximum value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_584007913129639935;\n\n    /// @dev The maximum whole value an unsigned 60.18-decimal fixed-point number can have.\n    uint256 internal constant MAX_WHOLE_UD60x18 =\n        115792089237316195423570985008687907853269984665640564039457_000000000000000000;\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @notice Calculates the arithmetic average of x and y, rounding down.\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The arithmetic average as an unsigned 60.18-decimal fixed-point number.\n    function avg(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // The operations can never overflow.\n        unchecked {\n            // The last operand checks if both x and y are odd and if that is the case, we add 1 to the result. We need\n            // to do this because if both numbers are odd, the 0.5 remainder gets truncated twice.\n            result = (x >> 1) + (y >> 1) + (x & y & 1);\n        }\n    }\n\n    /// @notice Yields the least unsigned 60.18 decimal fixed-point number greater than or equal to x.\n    ///\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    ///\n    /// Requirements:\n    /// - x must be less than or equal to MAX_WHOLE_UD60x18.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number to ceil.\n    /// @param result The least integer greater than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function ceil(uint256 x) internal pure returns (uint256 result) {\n        if (x > MAX_WHOLE_UD60x18) {\n            revert PRBMathUD60x18__CeilOverflow(x);\n        }\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"SCALE - remainder\" but faster.\n            let delta := sub(SCALE, remainder)\n\n            // Equivalent to \"x + delta * (remainder > 0 ? 1 : 0)\" but faster.\n            result := add(x, mul(delta, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Divides two unsigned 60.18-decimal fixed-point numbers, returning a new unsigned 60.18-decimal fixed-point number.\n    ///\n    /// @dev Uses mulDiv to enable overflow-safe multiplication and division.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    ///\n    /// @param x The numerator as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The denominator as an unsigned 60.18-decimal fixed-point number.\n    /// @param result The quotient as an unsigned 60.18-decimal fixed-point number.\n    function div(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDiv(x, SCALE, y);\n    }\n\n    /// @notice Returns Euler's number as an unsigned 60.18-decimal fixed-point number.\n    /// @dev See https://en.wikipedia.org/wiki/E_(mathematical_constant).\n    function e() internal pure returns (uint256 result) {\n        result = 2_718281828459045235;\n    }\n\n    /// @notice Calculates the natural exponent of x.\n    ///\n    /// @dev Based on the insight that e^x = 2^(x * log2(e)).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    /// - x must be less than 133.084258667509499441.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp(uint256 x) internal pure returns (uint256 result) {\n        // Without this check, the value passed to \"exp2\" would be greater than 192.\n        if (x >= 133_084258667509499441) {\n            revert PRBMathUD60x18__ExpInputTooBig(x);\n        }\n\n        // Do the fixed-point multiplication inline to save gas.\n        unchecked {\n            uint256 doubleScaleProduct = x * LOG2_E;\n            result = exp2((doubleScaleProduct + HALF_SCALE) / SCALE);\n        }\n    }\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    ///\n    /// @dev See https://ethereum.stackexchange.com/q/79903/24693.\n    ///\n    /// Requirements:\n    /// - x must be 192 or less.\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// @param x The exponent as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        // 2^192 doesn't fit within the 192.64-bit format used internally in this function.\n        if (x >= 192e18) {\n            revert PRBMathUD60x18__Exp2InputTooBig(x);\n        }\n\n        unchecked {\n            // Convert x to the 192.64-bit fixed-point format.\n            uint256 x192x64 = (x << 64) / SCALE;\n\n            // Pass x to the PRBMath.exp2 function, which uses the 192.64-bit fixed-point number representation.\n            result = PRBMath.exp2(x192x64);\n        }\n    }\n\n    /// @notice Yields the greatest unsigned 60.18 decimal fixed-point number less than or equal to x.\n    /// @dev Optimized for fractional value inputs, because for every whole value there are (1e18 - 1) fractional counterparts.\n    /// See https://en.wikipedia.org/wiki/Floor_and_ceiling_functions.\n    /// @param x The unsigned 60.18-decimal fixed-point number to floor.\n    /// @param result The greatest integer less than or equal to x, as an unsigned 60.18-decimal fixed-point number.\n    function floor(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            // Equivalent to \"x % SCALE\" but faster.\n            let remainder := mod(x, SCALE)\n\n            // Equivalent to \"x - remainder * (remainder > 0 ? 1 : 0)\" but faster.\n            result := sub(x, mul(remainder, gt(remainder, 0)))\n        }\n    }\n\n    /// @notice Yields the excess beyond the floor of x.\n    /// @dev Based on the odd function definition https://en.wikipedia.org/wiki/Fractional_part.\n    /// @param x The unsigned 60.18-decimal fixed-point number to get the fractional part of.\n    /// @param result The fractional part of x as an unsigned 60.18-decimal fixed-point number.\n    function frac(uint256 x) internal pure returns (uint256 result) {\n        assembly {\n            result := mod(x, SCALE)\n        }\n    }\n\n    /// @notice Converts a number from basic integer form to unsigned 60.18-decimal fixed-point representation.\n    ///\n    /// @dev Requirements:\n    /// - x must be less than or equal to MAX_UD60x18 divided by SCALE.\n    ///\n    /// @param x The basic integer to convert.\n    /// @param result The same number in unsigned 60.18-decimal fixed-point representation.\n    function fromUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__FromUintOverflow(x);\n            }\n            result = x * SCALE;\n        }\n    }\n\n    /// @notice Calculates geometric mean of x and y, i.e. sqrt(x * y), rounding down.\n    ///\n    /// @dev Requirements:\n    /// - x * y must fit within MAX_UD60x18, lest it overflows.\n    ///\n    /// @param x The first operand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The second operand as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function gm(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        unchecked {\n            // Checking for overflow this way is faster than letting Solidity do it.\n            uint256 xy = x * y;\n            if (xy / x != y) {\n                revert PRBMathUD60x18__GmOverflow(x, y);\n            }\n\n            // We don't need to multiply by the SCALE here because the x*y product had already picked up a factor of SCALE\n            // during multiplication. See the comments within the \"sqrt\" function.\n            result = PRBMath.sqrt(xy);\n        }\n    }\n\n    /// @notice Calculates 1 / x, rounding toward zero.\n    ///\n    /// @dev Requirements:\n    /// - x cannot be zero.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the inverse.\n    /// @return result The inverse as an unsigned 60.18-decimal fixed-point number.\n    function inv(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // 1e36 is SCALE * SCALE.\n            result = 1e36 / x;\n        }\n    }\n\n    /// @notice Calculates the natural logarithm of x.\n    ///\n    /// @dev Based on the insight that ln(x) = log2(x) / log2(e).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    /// - This doesn't return exactly 1 for 2.718281828459045235, for that we would need more fine-grained precision.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the natural logarithm.\n    /// @return result The natural logarithm as an unsigned 60.18-decimal fixed-point number.\n    function ln(uint256 x) internal pure returns (uint256 result) {\n        // Do the fixed-point multiplication inline to save gas. This is overflow-safe because the maximum value that log2(x)\n        // can return is 196205294292027477728.\n        unchecked {\n            result = (log2(x) * SCALE) / LOG2_E;\n        }\n    }\n\n    /// @notice Calculates the common logarithm of x.\n    ///\n    /// @dev First checks if x is an exact power of ten and it stops if yes. If it's not, calculates the common\n    /// logarithm based on the insight that log10(x) = log2(x) / log2(10).\n    ///\n    /// Requirements:\n    /// - All from \"log2\".\n    ///\n    /// Caveats:\n    /// - All from \"log2\".\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the common logarithm.\n    /// @return result The common logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log10(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n\n        // Note that the \"mul\" in this block is the assembly multiplication operation, not the \"mul\" function defined\n        // in this contract.\n        // prettier-ignore\n        assembly {\n            switch x\n            case 1 { result := mul(SCALE, sub(0, 18)) }\n            case 10 { result := mul(SCALE, sub(1, 18)) }\n            case 100 { result := mul(SCALE, sub(2, 18)) }\n            case 1000 { result := mul(SCALE, sub(3, 18)) }\n            case 10000 { result := mul(SCALE, sub(4, 18)) }\n            case 100000 { result := mul(SCALE, sub(5, 18)) }\n            case 1000000 { result := mul(SCALE, sub(6, 18)) }\n            case 10000000 { result := mul(SCALE, sub(7, 18)) }\n            case 100000000 { result := mul(SCALE, sub(8, 18)) }\n            case 1000000000 { result := mul(SCALE, sub(9, 18)) }\n            case 10000000000 { result := mul(SCALE, sub(10, 18)) }\n            case 100000000000 { result := mul(SCALE, sub(11, 18)) }\n            case 1000000000000 { result := mul(SCALE, sub(12, 18)) }\n            case 10000000000000 { result := mul(SCALE, sub(13, 18)) }\n            case 100000000000000 { result := mul(SCALE, sub(14, 18)) }\n            case 1000000000000000 { result := mul(SCALE, sub(15, 18)) }\n            case 10000000000000000 { result := mul(SCALE, sub(16, 18)) }\n            case 100000000000000000 { result := mul(SCALE, sub(17, 18)) }\n            case 1000000000000000000 { result := 0 }\n            case 10000000000000000000 { result := SCALE }\n            case 100000000000000000000 { result := mul(SCALE, 2) }\n            case 1000000000000000000000 { result := mul(SCALE, 3) }\n            case 10000000000000000000000 { result := mul(SCALE, 4) }\n            case 100000000000000000000000 { result := mul(SCALE, 5) }\n            case 1000000000000000000000000 { result := mul(SCALE, 6) }\n            case 10000000000000000000000000 { result := mul(SCALE, 7) }\n            case 100000000000000000000000000 { result := mul(SCALE, 8) }\n            case 1000000000000000000000000000 { result := mul(SCALE, 9) }\n            case 10000000000000000000000000000 { result := mul(SCALE, 10) }\n            case 100000000000000000000000000000 { result := mul(SCALE, 11) }\n            case 1000000000000000000000000000000 { result := mul(SCALE, 12) }\n            case 10000000000000000000000000000000 { result := mul(SCALE, 13) }\n            case 100000000000000000000000000000000 { result := mul(SCALE, 14) }\n            case 1000000000000000000000000000000000 { result := mul(SCALE, 15) }\n            case 10000000000000000000000000000000000 { result := mul(SCALE, 16) }\n            case 100000000000000000000000000000000000 { result := mul(SCALE, 17) }\n            case 1000000000000000000000000000000000000 { result := mul(SCALE, 18) }\n            case 10000000000000000000000000000000000000 { result := mul(SCALE, 19) }\n            case 100000000000000000000000000000000000000 { result := mul(SCALE, 20) }\n            case 1000000000000000000000000000000000000000 { result := mul(SCALE, 21) }\n            case 10000000000000000000000000000000000000000 { result := mul(SCALE, 22) }\n            case 100000000000000000000000000000000000000000 { result := mul(SCALE, 23) }\n            case 1000000000000000000000000000000000000000000 { result := mul(SCALE, 24) }\n            case 10000000000000000000000000000000000000000000 { result := mul(SCALE, 25) }\n            case 100000000000000000000000000000000000000000000 { result := mul(SCALE, 26) }\n            case 1000000000000000000000000000000000000000000000 { result := mul(SCALE, 27) }\n            case 10000000000000000000000000000000000000000000000 { result := mul(SCALE, 28) }\n            case 100000000000000000000000000000000000000000000000 { result := mul(SCALE, 29) }\n            case 1000000000000000000000000000000000000000000000000 { result := mul(SCALE, 30) }\n            case 10000000000000000000000000000000000000000000000000 { result := mul(SCALE, 31) }\n            case 100000000000000000000000000000000000000000000000000 { result := mul(SCALE, 32) }\n            case 1000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 33) }\n            case 10000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 34) }\n            case 100000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 35) }\n            case 1000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 36) }\n            case 10000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 37) }\n            case 100000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 38) }\n            case 1000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 39) }\n            case 10000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 40) }\n            case 100000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 41) }\n            case 1000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 42) }\n            case 10000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 43) }\n            case 100000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 44) }\n            case 1000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 45) }\n            case 10000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 46) }\n            case 100000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 47) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 48) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 49) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 50) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 51) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 52) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 53) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 54) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 55) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 56) }\n            case 1000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 57) }\n            case 10000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 58) }\n            case 100000000000000000000000000000000000000000000000000000000000000000000000000000 { result := mul(SCALE, 59) }\n            default {\n                result := MAX_UD60x18\n            }\n        }\n\n        if (result == MAX_UD60x18) {\n            // Do the fixed-point division inline to save gas. The denominator is log2(10).\n            unchecked {\n                result = (log2(x) * SCALE) / 3_321928094887362347;\n            }\n        }\n    }\n\n    /// @notice Calculates the binary logarithm of x.\n    ///\n    /// @dev Based on the iterative approximation algorithm.\n    /// https://en.wikipedia.org/wiki/Binary_logarithm#Iterative_approximation\n    ///\n    /// Requirements:\n    /// - x must be greater than or equal to SCALE, otherwise the result would be negative.\n    ///\n    /// Caveats:\n    /// - The results are nor perfectly accurate to the last decimal, due to the lossy precision of the iterative approximation.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the binary logarithm.\n    /// @return result The binary logarithm as an unsigned 60.18-decimal fixed-point number.\n    function log2(uint256 x) internal pure returns (uint256 result) {\n        if (x < SCALE) {\n            revert PRBMathUD60x18__LogInputTooSmall(x);\n        }\n        unchecked {\n            // Calculate the integer part of the logarithm and add it to the result and finally calculate y = x * 2^(-n).\n            uint256 n = PRBMath.mostSignificantBit(x / SCALE);\n\n            // The integer part of the logarithm as an unsigned 60.18-decimal fixed-point number. The operation can't overflow\n            // because n is maximum 255 and SCALE is 1e18.\n            result = n * SCALE;\n\n            // This is y = x * 2^(-n).\n            uint256 y = x >> n;\n\n            // If y = 1, the fractional part is zero.\n            if (y == SCALE) {\n                return result;\n            }\n\n            // Calculate the fractional part via the iterative approximation.\n            // The \"delta >>= 1\" part is equivalent to \"delta /= 2\", but shifting bits is faster.\n            for (uint256 delta = HALF_SCALE; delta > 0; delta >>= 1) {\n                y = (y * y) / SCALE;\n\n                // Is y^2 > 2 and so in the range [2,4)?\n                if (y >= 2 * SCALE) {\n                    // Add the 2^(-m) factor to the logarithm.\n                    result += delta;\n\n                    // Corresponds to z/2 on Wikipedia.\n                    y >>= 1;\n                }\n            }\n        }\n    }\n\n    /// @notice Multiplies two unsigned 60.18-decimal fixed-point numbers together, returning a new unsigned 60.18-decimal\n    /// fixed-point number.\n    /// @dev See the documentation for the \"PRBMath.mulDivFixedPoint\" function.\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The product as an unsigned 60.18-decimal fixed-point number.\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        result = PRBMath.mulDivFixedPoint(x, y);\n    }\n\n    /// @notice Returns PI as an unsigned 60.18-decimal fixed-point number.\n    function pi() internal pure returns (uint256 result) {\n        result = 3_141592653589793238;\n    }\n\n    /// @notice Raises x to the power of y.\n    ///\n    /// @dev Based on the insight that x^y = 2^(log2(x) * y).\n    ///\n    /// Requirements:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    ///\n    /// Caveats:\n    /// - All from \"exp2\", \"log2\" and \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x Number to raise to given power y, as an unsigned 60.18-decimal fixed-point number.\n    /// @param y Exponent to raise x to, as an unsigned 60.18-decimal fixed-point number.\n    /// @return result x raised to power y, as an unsigned 60.18-decimal fixed-point number.\n    function pow(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        if (x == 0) {\n            result = y == 0 ? SCALE : uint256(0);\n        } else {\n            result = exp2(mul(log2(x), y));\n        }\n    }\n\n    /// @notice Raises x (unsigned 60.18-decimal fixed-point number) to the power of y (basic unsigned integer) using the\n    /// famous algorithm \"exponentiation by squaring\".\n    ///\n    /// @dev See https://en.wikipedia.org/wiki/Exponentiation_by_squaring\n    ///\n    /// Requirements:\n    /// - The result must fit within MAX_UD60x18.\n    ///\n    /// Caveats:\n    /// - All from \"mul\".\n    /// - Assumes 0^0 is 1.\n    ///\n    /// @param x The base as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The exponent as an uint256.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function powu(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        // Calculate the first iteration of the loop in advance.\n        result = y & 1 > 0 ? x : SCALE;\n\n        // Equivalent to \"for(y /= 2; y > 0; y /= 2)\" but faster.\n        for (y >>= 1; y > 0; y >>= 1) {\n            x = PRBMath.mulDivFixedPoint(x, x);\n\n            // Equivalent to \"y % 2 == 1\" but faster.\n            if (y & 1 > 0) {\n                result = PRBMath.mulDivFixedPoint(result, x);\n            }\n        }\n    }\n\n    /// @notice Returns 1 as an unsigned 60.18-decimal fixed-point number.\n    function scale() internal pure returns (uint256 result) {\n        result = SCALE;\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Requirements:\n    /// - x must be less than MAX_UD60x18 / SCALE.\n    ///\n    /// @param x The unsigned 60.18-decimal fixed-point number for which to calculate the square root.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point .\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            if (x > MAX_UD60x18 / SCALE) {\n                revert PRBMathUD60x18__SqrtOverflow(x);\n            }\n            // Multiply x by the SCALE to account for the factor of SCALE that is picked up when multiplying two unsigned\n            // 60.18-decimal fixed-point numbers together (in this case, those two numbers are both the square root).\n            result = PRBMath.sqrt(x * SCALE);\n        }\n    }\n\n    /// @notice Converts a unsigned 60.18-decimal fixed-point number to basic integer form, rounding down in the process.\n    /// @param x The unsigned 60.18-decimal fixed-point number to convert.\n    /// @return result The same number in basic integer form.\n    function toUint(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            result = x / SCALE;\n        }\n    }\n}\n"
    },
    "prb-math/contracts/PRBMath.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\npragma solidity >=0.8.4;\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivFixedPointOverflow(uint256 prod1);\n\n/// @notice Emitted when the result overflows uint256.\nerror PRBMath__MulDivOverflow(uint256 prod1, uint256 denominator);\n\n/// @notice Emitted when one of the inputs is type(int256).min.\nerror PRBMath__MulDivSignedInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows int256.\nerror PRBMath__MulDivSignedOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is MIN_SD59x18.\nerror PRBMathSD59x18__AbsInputTooSmall();\n\n/// @notice Emitted when ceiling a number overflows SD59x18.\nerror PRBMathSD59x18__CeilOverflow(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__DivInputTooSmall();\n\n/// @notice Emitted when one of the intermediary unsigned results overflows SD59x18.\nerror PRBMathSD59x18__DivOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathSD59x18__ExpInputTooBig(int256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathSD59x18__Exp2InputTooBig(int256 x);\n\n/// @notice Emitted when flooring a number underflows SD59x18.\nerror PRBMathSD59x18__FloorUnderflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format overflows SD59x18.\nerror PRBMathSD59x18__FromIntOverflow(int256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format underflows SD59x18.\nerror PRBMathSD59x18__FromIntUnderflow(int256 x);\n\n/// @notice Emitted when the product of the inputs is negative.\nerror PRBMathSD59x18__GmNegativeProduct(int256 x, int256 y);\n\n/// @notice Emitted when multiplying the inputs overflows SD59x18.\nerror PRBMathSD59x18__GmOverflow(int256 x, int256 y);\n\n/// @notice Emitted when the input is less than or equal to zero.\nerror PRBMathSD59x18__LogInputTooSmall(int256 x);\n\n/// @notice Emitted when one of the inputs is MIN_SD59x18.\nerror PRBMathSD59x18__MulInputTooSmall();\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__MulOverflow(uint256 rAbs);\n\n/// @notice Emitted when the intermediary absolute result overflows SD59x18.\nerror PRBMathSD59x18__PowuOverflow(uint256 rAbs);\n\n/// @notice Emitted when the input is negative.\nerror PRBMathSD59x18__SqrtNegativeInput(int256 x);\n\n/// @notice Emitted when the calculating the square root overflows SD59x18.\nerror PRBMathSD59x18__SqrtOverflow(int256 x);\n\n/// @notice Emitted when addition overflows UD60x18.\nerror PRBMathUD60x18__AddOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when ceiling a number overflows UD60x18.\nerror PRBMathUD60x18__CeilOverflow(uint256 x);\n\n/// @notice Emitted when the input is greater than 133.084258667509499441.\nerror PRBMathUD60x18__ExpInputTooBig(uint256 x);\n\n/// @notice Emitted when the input is greater than 192.\nerror PRBMathUD60x18__Exp2InputTooBig(uint256 x);\n\n/// @notice Emitted when converting a basic integer to the fixed-point format format overflows UD60x18.\nerror PRBMathUD60x18__FromUintOverflow(uint256 x);\n\n/// @notice Emitted when multiplying the inputs overflows UD60x18.\nerror PRBMathUD60x18__GmOverflow(uint256 x, uint256 y);\n\n/// @notice Emitted when the input is less than 1.\nerror PRBMathUD60x18__LogInputTooSmall(uint256 x);\n\n/// @notice Emitted when the calculating the square root overflows UD60x18.\nerror PRBMathUD60x18__SqrtOverflow(uint256 x);\n\n/// @notice Emitted when subtraction underflows UD60x18.\nerror PRBMathUD60x18__SubUnderflow(uint256 x, uint256 y);\n\n/// @dev Common mathematical functions used in both PRBMathSD59x18 and PRBMathUD60x18. Note that this shared library\n/// does not always assume the signed 59.18-decimal fixed-point or the unsigned 60.18-decimal fixed-point\n/// representation. When it does not, it is explicitly mentioned in the NatSpec documentation.\nlibrary PRBMath {\n    /// STRUCTS ///\n\n    struct SD59x18 {\n        int256 value;\n    }\n\n    struct UD60x18 {\n        uint256 value;\n    }\n\n    /// STORAGE ///\n\n    /// @dev How many trailing decimals can be represented.\n    uint256 internal constant SCALE = 1e18;\n\n    /// @dev Largest power of two divisor of SCALE.\n    uint256 internal constant SCALE_LPOTD = 262144;\n\n    /// @dev SCALE inverted mod 2^256.\n    uint256 internal constant SCALE_INVERSE =\n        78156646155174841979727994598816262306175212592076161876661_508869554232690281;\n\n    /// FUNCTIONS ///\n\n    /// @notice Calculates the binary exponent of x using the binary fraction method.\n    /// @dev Has to use 192.64-bit fixed-point numbers.\n    /// See https://ethereum.stackexchange.com/a/96594/24693.\n    /// @param x The exponent as an unsigned 192.64-bit fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function exp2(uint256 x) internal pure returns (uint256 result) {\n        unchecked {\n            // Start from 0.5 in the 192.64-bit fixed-point format.\n            result = 0x800000000000000000000000000000000000000000000000;\n\n            // Multiply the result by root(2, 2^-i) when the bit at position i is 1. None of the intermediary results overflows\n            // because the initial result is 2^191 and all magic factors are less than 2^65.\n            if (x & 0x8000000000000000 > 0) {\n                result = (result * 0x16A09E667F3BCC909) >> 64;\n            }\n            if (x & 0x4000000000000000 > 0) {\n                result = (result * 0x1306FE0A31B7152DF) >> 64;\n            }\n            if (x & 0x2000000000000000 > 0) {\n                result = (result * 0x1172B83C7D517ADCE) >> 64;\n            }\n            if (x & 0x1000000000000000 > 0) {\n                result = (result * 0x10B5586CF9890F62A) >> 64;\n            }\n            if (x & 0x800000000000000 > 0) {\n                result = (result * 0x1059B0D31585743AE) >> 64;\n            }\n            if (x & 0x400000000000000 > 0) {\n                result = (result * 0x102C9A3E778060EE7) >> 64;\n            }\n            if (x & 0x200000000000000 > 0) {\n                result = (result * 0x10163DA9FB33356D8) >> 64;\n            }\n            if (x & 0x100000000000000 > 0) {\n                result = (result * 0x100B1AFA5ABCBED61) >> 64;\n            }\n            if (x & 0x80000000000000 > 0) {\n                result = (result * 0x10058C86DA1C09EA2) >> 64;\n            }\n            if (x & 0x40000000000000 > 0) {\n                result = (result * 0x1002C605E2E8CEC50) >> 64;\n            }\n            if (x & 0x20000000000000 > 0) {\n                result = (result * 0x100162F3904051FA1) >> 64;\n            }\n            if (x & 0x10000000000000 > 0) {\n                result = (result * 0x1000B175EFFDC76BA) >> 64;\n            }\n            if (x & 0x8000000000000 > 0) {\n                result = (result * 0x100058BA01FB9F96D) >> 64;\n            }\n            if (x & 0x4000000000000 > 0) {\n                result = (result * 0x10002C5CC37DA9492) >> 64;\n            }\n            if (x & 0x2000000000000 > 0) {\n                result = (result * 0x1000162E525EE0547) >> 64;\n            }\n            if (x & 0x1000000000000 > 0) {\n                result = (result * 0x10000B17255775C04) >> 64;\n            }\n            if (x & 0x800000000000 > 0) {\n                result = (result * 0x1000058B91B5BC9AE) >> 64;\n            }\n            if (x & 0x400000000000 > 0) {\n                result = (result * 0x100002C5C89D5EC6D) >> 64;\n            }\n            if (x & 0x200000000000 > 0) {\n                result = (result * 0x10000162E43F4F831) >> 64;\n            }\n            if (x & 0x100000000000 > 0) {\n                result = (result * 0x100000B1721BCFC9A) >> 64;\n            }\n            if (x & 0x80000000000 > 0) {\n                result = (result * 0x10000058B90CF1E6E) >> 64;\n            }\n            if (x & 0x40000000000 > 0) {\n                result = (result * 0x1000002C5C863B73F) >> 64;\n            }\n            if (x & 0x20000000000 > 0) {\n                result = (result * 0x100000162E430E5A2) >> 64;\n            }\n            if (x & 0x10000000000 > 0) {\n                result = (result * 0x1000000B172183551) >> 64;\n            }\n            if (x & 0x8000000000 > 0) {\n                result = (result * 0x100000058B90C0B49) >> 64;\n            }\n            if (x & 0x4000000000 > 0) {\n                result = (result * 0x10000002C5C8601CC) >> 64;\n            }\n            if (x & 0x2000000000 > 0) {\n                result = (result * 0x1000000162E42FFF0) >> 64;\n            }\n            if (x & 0x1000000000 > 0) {\n                result = (result * 0x10000000B17217FBB) >> 64;\n            }\n            if (x & 0x800000000 > 0) {\n                result = (result * 0x1000000058B90BFCE) >> 64;\n            }\n            if (x & 0x400000000 > 0) {\n                result = (result * 0x100000002C5C85FE3) >> 64;\n            }\n            if (x & 0x200000000 > 0) {\n                result = (result * 0x10000000162E42FF1) >> 64;\n            }\n            if (x & 0x100000000 > 0) {\n                result = (result * 0x100000000B17217F8) >> 64;\n            }\n            if (x & 0x80000000 > 0) {\n                result = (result * 0x10000000058B90BFC) >> 64;\n            }\n            if (x & 0x40000000 > 0) {\n                result = (result * 0x1000000002C5C85FE) >> 64;\n            }\n            if (x & 0x20000000 > 0) {\n                result = (result * 0x100000000162E42FF) >> 64;\n            }\n            if (x & 0x10000000 > 0) {\n                result = (result * 0x1000000000B17217F) >> 64;\n            }\n            if (x & 0x8000000 > 0) {\n                result = (result * 0x100000000058B90C0) >> 64;\n            }\n            if (x & 0x4000000 > 0) {\n                result = (result * 0x10000000002C5C860) >> 64;\n            }\n            if (x & 0x2000000 > 0) {\n                result = (result * 0x1000000000162E430) >> 64;\n            }\n            if (x & 0x1000000 > 0) {\n                result = (result * 0x10000000000B17218) >> 64;\n            }\n            if (x & 0x800000 > 0) {\n                result = (result * 0x1000000000058B90C) >> 64;\n            }\n            if (x & 0x400000 > 0) {\n                result = (result * 0x100000000002C5C86) >> 64;\n            }\n            if (x & 0x200000 > 0) {\n                result = (result * 0x10000000000162E43) >> 64;\n            }\n            if (x & 0x100000 > 0) {\n                result = (result * 0x100000000000B1721) >> 64;\n            }\n            if (x & 0x80000 > 0) {\n                result = (result * 0x10000000000058B91) >> 64;\n            }\n            if (x & 0x40000 > 0) {\n                result = (result * 0x1000000000002C5C8) >> 64;\n            }\n            if (x & 0x20000 > 0) {\n                result = (result * 0x100000000000162E4) >> 64;\n            }\n            if (x & 0x10000 > 0) {\n                result = (result * 0x1000000000000B172) >> 64;\n            }\n            if (x & 0x8000 > 0) {\n                result = (result * 0x100000000000058B9) >> 64;\n            }\n            if (x & 0x4000 > 0) {\n                result = (result * 0x10000000000002C5D) >> 64;\n            }\n            if (x & 0x2000 > 0) {\n                result = (result * 0x1000000000000162E) >> 64;\n            }\n            if (x & 0x1000 > 0) {\n                result = (result * 0x10000000000000B17) >> 64;\n            }\n            if (x & 0x800 > 0) {\n                result = (result * 0x1000000000000058C) >> 64;\n            }\n            if (x & 0x400 > 0) {\n                result = (result * 0x100000000000002C6) >> 64;\n            }\n            if (x & 0x200 > 0) {\n                result = (result * 0x10000000000000163) >> 64;\n            }\n            if (x & 0x100 > 0) {\n                result = (result * 0x100000000000000B1) >> 64;\n            }\n            if (x & 0x80 > 0) {\n                result = (result * 0x10000000000000059) >> 64;\n            }\n            if (x & 0x40 > 0) {\n                result = (result * 0x1000000000000002C) >> 64;\n            }\n            if (x & 0x20 > 0) {\n                result = (result * 0x10000000000000016) >> 64;\n            }\n            if (x & 0x10 > 0) {\n                result = (result * 0x1000000000000000B) >> 64;\n            }\n            if (x & 0x8 > 0) {\n                result = (result * 0x10000000000000006) >> 64;\n            }\n            if (x & 0x4 > 0) {\n                result = (result * 0x10000000000000003) >> 64;\n            }\n            if (x & 0x2 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n            if (x & 0x1 > 0) {\n                result = (result * 0x10000000000000001) >> 64;\n            }\n\n            // We're doing two things at the same time:\n            //\n            //   1. Multiply the result by 2^n + 1, where \"2^n\" is the integer part and the one is added to account for\n            //      the fact that we initially set the result to 0.5. This is accomplished by subtracting from 191\n            //      rather than 192.\n            //   2. Convert the result to the unsigned 60.18-decimal fixed-point format.\n            //\n            // This works because 2^(191-ip) = 2^ip / 2^191, where \"ip\" is the integer part \"2^n\".\n            result *= SCALE;\n            result >>= (191 - (x >> 64));\n        }\n    }\n\n    /// @notice Finds the zero-based index of the first one in the binary representation of x.\n    /// @dev See the note on msb in the \"Find First Set\" Wikipedia article https://en.wikipedia.org/wiki/Find_first_set\n    /// @param x The uint256 number for which to find the index of the most significant bit.\n    /// @return msb The index of the most significant bit as an uint256.\n    function mostSignificantBit(uint256 x) internal pure returns (uint256 msb) {\n        if (x >= 2**128) {\n            x >>= 128;\n            msb += 128;\n        }\n        if (x >= 2**64) {\n            x >>= 64;\n            msb += 64;\n        }\n        if (x >= 2**32) {\n            x >>= 32;\n            msb += 32;\n        }\n        if (x >= 2**16) {\n            x >>= 16;\n            msb += 16;\n        }\n        if (x >= 2**8) {\n            x >>= 8;\n            msb += 8;\n        }\n        if (x >= 2**4) {\n            x >>= 4;\n            msb += 4;\n        }\n        if (x >= 2**2) {\n            x >>= 2;\n            msb += 2;\n        }\n        if (x >= 2**1) {\n            // No need to shift x any more.\n            msb += 1;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv.\n    ///\n    /// Requirements:\n    /// - The denominator cannot be zero.\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The multiplicand as an uint256.\n    /// @param y The multiplier as an uint256.\n    /// @param denominator The divisor as an uint256.\n    /// @return result The result as an uint256.\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n        // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n        // variables such that product = prod1 * 2^256 + prod0.\n        uint256 prod0; // Least significant 256 bits of the product\n        uint256 prod1; // Most significant 256 bits of the product\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        // Handle non-overflow cases, 256 by 256 division.\n        if (prod1 == 0) {\n            unchecked {\n                result = prod0 / denominator;\n            }\n            return result;\n        }\n\n        // Make sure the result is less than 2^256. Also prevents denominator == 0.\n        if (prod1 >= denominator) {\n            revert PRBMath__MulDivOverflow(prod1, denominator);\n        }\n\n        ///////////////////////////////////////////////\n        // 512 by 256 division.\n        ///////////////////////////////////////////////\n\n        // Make division exact by subtracting the remainder from [prod1 prod0].\n        uint256 remainder;\n        assembly {\n            // Compute remainder using mulmod.\n            remainder := mulmod(x, y, denominator)\n\n            // Subtract 256 bit number from 512 bit number.\n            prod1 := sub(prod1, gt(remainder, prod0))\n            prod0 := sub(prod0, remainder)\n        }\n\n        // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n        // See https://cs.stackexchange.com/q/138556/92363.\n        unchecked {\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 lpotdod = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by lpotdod.\n                denominator := div(denominator, lpotdod)\n\n                // Divide [prod1 prod0] by lpotdod.\n                prod0 := div(prod0, lpotdod)\n\n                // Flip lpotdod such that it is 2^256 / lpotdod. If lpotdod is zero, then it becomes one.\n                lpotdod := add(div(sub(0, lpotdod), lpotdod), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * lpotdod;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷1e18) with full precision.\n    ///\n    /// @dev Variant of \"mulDiv\" with constant folding, i.e. in which the denominator is always 1e18. Before returning the\n    /// final result, we add 1 if (x * y) % SCALE >= HALF_SCALE. Without this, 6.6e-19 would be truncated to 0 instead of\n    /// being rounded to 1e-18.  See \"Listing 6\" and text above it at https://accu.org/index.php/journals/1717.\n    ///\n    /// Requirements:\n    /// - The result must fit within uint256.\n    ///\n    /// Caveats:\n    /// - The body is purposely left uncommented; see the NatSpec comments in \"PRBMath.mulDiv\" to understand how this works.\n    /// - It is assumed that the result can never be type(uint256).max when x and y solve the following two equations:\n    ///     1. x * y = type(uint256).max * SCALE\n    ///     2. (x * y) % SCALE >= SCALE / 2\n    ///\n    /// @param x The multiplicand as an unsigned 60.18-decimal fixed-point number.\n    /// @param y The multiplier as an unsigned 60.18-decimal fixed-point number.\n    /// @return result The result as an unsigned 60.18-decimal fixed-point number.\n    function mulDivFixedPoint(uint256 x, uint256 y) internal pure returns (uint256 result) {\n        uint256 prod0;\n        uint256 prod1;\n        assembly {\n            let mm := mulmod(x, y, not(0))\n            prod0 := mul(x, y)\n            prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n        }\n\n        if (prod1 >= SCALE) {\n            revert PRBMath__MulDivFixedPointOverflow(prod1);\n        }\n\n        uint256 remainder;\n        uint256 roundUpUnit;\n        assembly {\n            remainder := mulmod(x, y, SCALE)\n            roundUpUnit := gt(remainder, 499999999999999999)\n        }\n\n        if (prod1 == 0) {\n            unchecked {\n                result = (prod0 / SCALE) + roundUpUnit;\n                return result;\n            }\n        }\n\n        assembly {\n            result := add(\n                mul(\n                    or(\n                        div(sub(prod0, remainder), SCALE_LPOTD),\n                        mul(sub(prod1, gt(remainder, prod0)), add(div(sub(0, SCALE_LPOTD), SCALE_LPOTD), 1))\n                    ),\n                    SCALE_INVERSE\n                ),\n                roundUpUnit\n            )\n        }\n    }\n\n    /// @notice Calculates floor(x*y÷denominator) with full precision.\n    ///\n    /// @dev An extension of \"mulDiv\" for signed numbers. Works by computing the signs and the absolute values separately.\n    ///\n    /// Requirements:\n    /// - None of the inputs can be type(int256).min.\n    /// - The result must fit within int256.\n    ///\n    /// @param x The multiplicand as an int256.\n    /// @param y The multiplier as an int256.\n    /// @param denominator The divisor as an int256.\n    /// @return result The result as an int256.\n    function mulDivSigned(\n        int256 x,\n        int256 y,\n        int256 denominator\n    ) internal pure returns (int256 result) {\n        if (x == type(int256).min || y == type(int256).min || denominator == type(int256).min) {\n            revert PRBMath__MulDivSignedInputTooSmall();\n        }\n\n        // Get hold of the absolute values of x, y and the denominator.\n        uint256 ax;\n        uint256 ay;\n        uint256 ad;\n        unchecked {\n            ax = x < 0 ? uint256(-x) : uint256(x);\n            ay = y < 0 ? uint256(-y) : uint256(y);\n            ad = denominator < 0 ? uint256(-denominator) : uint256(denominator);\n        }\n\n        // Compute the absolute value of (x*y)÷denominator. The result must fit within int256.\n        uint256 rAbs = mulDiv(ax, ay, ad);\n        if (rAbs > uint256(type(int256).max)) {\n            revert PRBMath__MulDivSignedOverflow(rAbs);\n        }\n\n        // Get the signs of x, y and the denominator.\n        uint256 sx;\n        uint256 sy;\n        uint256 sd;\n        assembly {\n            sx := sgt(x, sub(0, 1))\n            sy := sgt(y, sub(0, 1))\n            sd := sgt(denominator, sub(0, 1))\n        }\n\n        // XOR over sx, sy and sd. This is checking whether there are one or three negative signs in the inputs.\n        // If yes, the result should be negative.\n        result = sx ^ sy ^ sd == 0 ? -int256(rAbs) : int256(rAbs);\n    }\n\n    /// @notice Calculates the square root of x, rounding down.\n    /// @dev Uses the Babylonian method https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method.\n    ///\n    /// Caveats:\n    /// - This function does not work with fixed-point numbers.\n    ///\n    /// @param x The uint256 number for which to calculate the square root.\n    /// @return result The result as an uint256.\n    function sqrt(uint256 x) internal pure returns (uint256 result) {\n        if (x == 0) {\n            return 0;\n        }\n\n        // Set the initial guess to the least power of two that is greater than or equal to sqrt(x).\n        uint256 xAux = uint256(x);\n        result = 1;\n        if (xAux >= 0x100000000000000000000000000000000) {\n            xAux >>= 128;\n            result <<= 64;\n        }\n        if (xAux >= 0x10000000000000000) {\n            xAux >>= 64;\n            result <<= 32;\n        }\n        if (xAux >= 0x100000000) {\n            xAux >>= 32;\n            result <<= 16;\n        }\n        if (xAux >= 0x10000) {\n            xAux >>= 16;\n            result <<= 8;\n        }\n        if (xAux >= 0x100) {\n            xAux >>= 8;\n            result <<= 4;\n        }\n        if (xAux >= 0x10) {\n            xAux >>= 4;\n            result <<= 2;\n        }\n        if (xAux >= 0x8) {\n            result <<= 1;\n        }\n\n        // The operations can never overflow because the result is max 2^127 when it enters this block.\n        unchecked {\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1;\n            result = (result + x / result) >> 1; // Seven iterations should be enough\n            uint256 roundedDownResult = x / result;\n            return result >= roundedDownResult ? roundedDownResult : result;\n        }\n    }\n}\n"
    },
    "contracts/mocks/LandSvgLibMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../lib/LandSvgLib.sol\";\n\n/**\n * @title Land SVG Library Mock\n *\n * @notice Used to test Land SVG Library, by exposing it's internal function\n *\n * @author Yuri Fernandes\n */\n contract LandSvgLibMock {\n\n     /**\n\t * @dev Calculates string for the land name based on plot data.\n\t *\n\t * @param _regionId PlotView.regionId\n\t * @param _x PlotView.x coordinate\n\t * @param _y PlotView.y coordinate\n\t * @return SVG name attribute\n\t */\n     function generateLandName(uint8 _regionId, uint16 _x, uint16 _y) public pure returns (string memory) {\n         return LandSvgLib.generateLandName(_regionId, _x, _y);\n     }\n }"
    },
    "contracts/token/LandDescriptorImpl.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/LandERC721Spec.sol\";\nimport \"../lib/LandSvgLib.sol\";\n\n/**\n * @title Land Descriptor Implementation\n *\n * @notice Basic implementation of the LandDescriptor interface\n *\n * @author Pedro Bergamini, Basil Gorin\n */\ncontract LandDescriptorImpl is LandDescriptor {\n\t/**\n\t * @inheritdoc LandDescriptor\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n\t\t// assuming the function was called by the LandERC721 contract itself,\n\t\t// fetch the token metadata from it\n\t\tLandLib.PlotView memory _plot = LandERC721Metadata(msg.sender).viewMetadata(_tokenId);\n\n\t\t// unpack the `_plot` structure and delegate generation into the lib\n\t\treturn LandSvgLib.constructTokenURI(\n\t\t\t_plot.regionId,\n\t\t\t_plot.x,\n\t\t\t_plot.y,\n\t\t\t_plot.tierId,\n\t\t\t_plot.size,\n\t\t\t_plot.landmarkTypeId,\n\t\t\t_plot.sites\n\t\t);\n\t}\n}\n"
    },
    "contracts/mocks/LandDescriptorMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/LandDescriptorImpl.sol\";\n\n/**\n * @title Land Descriptor Mock\n *\n * @dev Allows to override `tokenURI`\n *\n * @author Basil Gorin\n */\ncontract LandDescriptorMock is LandDescriptorImpl {\n\t/// @dev Defines if tokenURI() should be overridden\n\tbool private _tokenURIOverride;\n\n\t/// @dev Overrides tokenURI() if `_tokenURIOverride` is true\n\tstring private _tokenURIValue;\n\n\t/// @dev Sets tokenURI() override\n\tfunction setTokenURIOverride(string calldata _value) public {\n\t\t_tokenURIOverride = true;\n\t\t_tokenURIValue = _value;\n\t}\n\n\t/// @dev Removes tokenURI() override\n\tfunction removeTokenURIOverride() public {\n\t\t_tokenURIOverride = false;\n\t}\n\n\t/**\n\t * @inheritdoc LandDescriptorImpl\n\t */\n\tfunction tokenURI(uint256 _tokenId) public view virtual override returns (string memory) {\n\t\t// override tokenURI if required, delegate to super otherwise\n\t\treturn _tokenURIOverride? _tokenURIValue: super.tokenURI(_tokenId);\n\t}\n}\n"
    },
    "contracts/mocks/LandNFTMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/LandERC721.sol\";\n\n/**\n * @title Land NFT Mock\n *\n * @notice LandERC721 mock allows to disable supported ERC165 interfaces\n *\n * @author Basil Gorin\n */\ncontract LandNFTMock is LandERC721 {\n\t/**\n\t * @dev Creates/deploys Land NFT Mock instance\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) {\n\t\t// deproxify it\n\t\tpostConstruct(_name, _symbol);\n\t}\n\n\t/**\n\t * @dev Interfaces which should not be reported as supported ones by `supportsInterface`\n\t */\n\tmapping(bytes4 => bool) private excludedInterfaces;\n\n\t/// @dev Allows to override supportsInterface behaviour by excluding the interface\n\tfunction excludeInterface(bytes4 interfaceId, bool value) public {\n\t\texcludedInterfaces[interfaceId] = value;\n\t}\n\n\t/**\n\t * @inheritdoc IERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n\t\t// calculate based on inherited interfaces taking into account excluded interfaces\n\t\treturn !excludedInterfaces[interfaceId] && super.supportsInterface(interfaceId);\n\t}\n}\n"
    },
    "contracts/protocol/LandSalePriceOracleV1.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC165Spec.sol\";\nimport \"../interfaces/PriceOracleSpec.sol\";\nimport \"../utils/UpgradeableAccessControl.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title Chainlink Price Feed Aggregator based Land Sale Price Oracle\n *\n * @notice LandSalePriceOracle implementation based on ILV/ETH Chainlink price feeds,\n *      see https://docs.chain.link/docs/ethereum-addresses/\n *      see https://docs.chain.link/docs/using-chainlink-reference-contracts/\n *\n * @author Basil Gorin\n */\ncontract LandSalePriceOracleV1 is ERC165, LandSalePriceOracle, UpgradeableAccessControl {\n\t/**\n\t * @notice Chainlink ILV/ETH price feed aggregator maintains ILV/ETH price feed\n\t */\n\tAggregatorV3Interface public aggregator;\n\n\t/**\n\t * @notice When communicating with Chainlink ILV/ETH price feed, we verify how old\n\t *      the IV/ETH price is, and if it is older than `oldAnswerThreshold`, the answer\n\t *      is treated as old and is not used: `ethToIlv` conversion function throws in this case\n\t */\n\tuint256 public oldAnswerThreshold;\n\n\t/**\n\t * @notice Price Oracle manager is responsible for updating `oldAnswerThreshold` value,\n\t *      and other price oracle configuration values in the future\n\t *\n\t * @dev Role ROLE_PRICE_ORACLE_MANAGER allows updating the `oldAnswerThreshold` value\n\t *      (executing `setOldAnswerThreshold` function)\n\t */\n\tuint32 public constant ROLE_PRICE_ORACLE_MANAGER = 0x0001_0000;\n\n\t/**\n\t * @dev Fired in setOldAnswerThreshold()\n\t *\n\t * @param _by an address which executed update\n\t * @param _oldVal old oldAnswerThreshold value\n\t * @param _newVal new oldAnswerThreshold value\n\t */\n\tevent OldAnswerThresholdUpdated(address indexed _by, uint256 _oldVal, uint256 _newVal);\n\n\t/**\n\t * @dev \"Constructor replacement\" for upgradeable, must be execute immediately after deployment\n\t *      see https://docs.openzeppelin.com/upgrades-plugins/1.x/writing-upgradeable#initializers\n\t *\n\t * @param _aggregator Chainlink ILV/ETH price feed aggregator address\n\t */\n\tfunction postConstruct(address _aggregator) public virtual initializer {\n\t\t// verify the inputs are set\n\t\trequire(_aggregator != address(0), \"aggregator address is not set\");\n\n\t\t// assign the addresses\n\t\taggregator = AggregatorV3Interface(_aggregator);\n\n\t\t// set the default value for the threshold\n\t\toldAnswerThreshold = 30 hours;\n\n\t\t// verify the inputs are valid smart contracts of the expected interfaces\n\t\t// since Chainlink AggregatorV3Interface doesn't support ERC165, verify\n\t\t// by executing the functions we're going to use anyway\n\t\t// get the data\n\t\tuint8 decimals = aggregator.decimals();\n\t\t(\n\t\t\tuint80 roundId,\n\t\t\tint256 answer,\n\t\t\tuint256 startedAt,\n\t\t\tuint256 updatedAt,\n\t\t\tuint80 answeredInRound\n\t\t) = aggregator.latestRoundData();\n\t\t// verify the response\n\t\trequire(\n\t\t\tdecimals > 0 && roundId > 0 && answer > 0 && startedAt > 0 && updatedAt > 0 && answeredInRound > 0,\n\t\t\t\"unexpected aggregator response\"\n\t\t);\n\n\t\t// execute all parent initializers in cascade\n\t\tUpgradeableAccessControl._postConstruct(msg.sender);\n\t}\n\n\t/**\n\t * @notice Restricted access function to update `oldAnswerThreshold` value, used\n\t *       in `ethToIlv` conversion function to determine if Chainlink ILV/ETH price feed\n\t *       returns the value fresh enough to be used\n\t *\n\t * @notice Note: `ethToIlv` conversion function throws if Chainlink ILV/ETH price feed\n\t *      answer is older then `oldAnswerThreshold` value\n\t *\n\t * @notice Chainlink is expected to update ILV/ETH price at least one per day (24 hours)\n\t *      therefore `oldAnswerThreshold` should be kept bigger than 24 hours\n\t *\n\t * @param _oldAnswerThreshold `oldAnswerThreshold` value to set\n\t */\n\tfunction setOldAnswerThreshold(uint256 _oldAnswerThreshold) public {\n\t\t// verify the access permission\n\t\trequire(isSenderInRole(ROLE_PRICE_ORACLE_MANAGER), \"access denied\");\n\n\t\t// check that the value supplied resides in a reasonable bounds\n\t\trequire(_oldAnswerThreshold > 1 hours, \"threshold too low\");\n\t\trequire(_oldAnswerThreshold < 7 days, \"threshold too high\");\n\n\t\t// emit an event first - to log both old and new values\n\t\temit OldAnswerThresholdUpdated(msg.sender, oldAnswerThreshold, _oldAnswerThreshold);\n\n\t\t// update the `oldAnswerThreshold` value\n\t\toldAnswerThreshold = _oldAnswerThreshold;\n\t}\n\n\t/**\n\t * @inheritdoc ERC165\n\t */\n\tfunction supportsInterface(bytes4 interfaceID) public view virtual override returns (bool) {\n\t\t// determine and return the interface support\n\t\treturn interfaceID == type(LandSalePriceOracle).interfaceId;\n\t}\n\n\t/**\n\t * @inheritdoc LandSalePriceOracle\n\t */\n\tfunction ethToIlv(uint256 ethOut) public view virtual override returns (uint256 ilvIn) {\n\t\t// get the latest round data from Chainlink price feed aggregator\n\t\t// see https://docs.chain.link/docs/price-feeds-api-reference/#latestrounddata\n\t\t(\n\t\t\tuint80 roundId,\n\t\t\tint256 answer,\n\t\t\tuint256 startedAt,\n\t\t\tuint256 updatedAt,\n\t\t\tuint80 answeredInRound\n\t\t) = aggregator.latestRoundData();\n\n\t\t// verify if the data obtained from Chainlink looks fresh, updated recently\n\t\t// TODO: review and check with Chainlink this is a correct way of ensuring data freshness\n\t\trequire(roundId == answeredInRound && startedAt <= updatedAt && updatedAt <= now256(), \"invalid answer\");\n\t\trequire(updatedAt > now256() - oldAnswerThreshold, \"answer is too old\");\n\n\t\t// calculate according to `ethOut * ilvIn / ethOut` formula and return\n\t\treturn ethOut * 10 ** aggregator.decimals() / uint256(answer);\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view virtual returns (uint256) {\n\t\t// return current block timestamp\n\t\treturn block.timestamp;\n\t}\n}\n"
    },
    "@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n}\n"
    },
    "contracts/mocks/LandSalePriceOracleV1Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/LandSalePriceOracleV1.sol\";\n\n/**\n * @title Chainlink Land Sale Price Oracle Mock\n *\n * @notice Supports the Land Sale with the ETH/ILV conversion required\n *\n * @dev Enables oracle price override, playing with current timestamp\n *\n * @author Basil Gorin\n */\ncontract LandSalePriceOracleV1Mock is LandSalePriceOracleV1 {\n\t// override the value calculated based on the feed\n\tuint256 public ethToIlvOverride;\n\n\t/// @dev overridden value to use as now32()\n\tuint256 private _now256;\n\n\t/// @dev overrides now256()\n\tfunction setNow256(uint256 value) public {\n\t\t_now256 = value;\n\t}\n\n\t/**\n\t * @inheritdoc LandSalePriceOracleV1\n\t */\n\tfunction postConstruct(address _aggregator) public override initializer {\n\t\tsuper.postConstruct(_aggregator);\n\t\tethToIlvOverride = type(uint256).max;\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view override returns (uint256) {\n\t\treturn _now256 > 0? _now256: super.now256();\n\t}\n\n\t// overrides the `ethToIlv` completely and forces it to always return the value specified\n\tfunction setEthToIlvOverride(uint256 _ethToIlvOverride) public {\n\t\tethToIlvOverride = _ethToIlvOverride;\n\t}\n\n\t/**\n\t * @inheritdoc LandSalePriceOracle\n\t */\n\tfunction ethToIlv(uint256 _ethOut) public view virtual override returns (uint256 _ilvIn) {\n\t\treturn ethToIlvOverride < type(uint256).max? ethToIlvOverride: super.ethToIlv(_ethOut);\n\t}\n}\n"
    },
    "contracts/mocks/ChainlinkAggregatorV3Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC165Spec.sol\";\nimport \"../interfaces/PriceOracleSpec.sol\";\nimport \"../protocol/LandSalePriceOracleV1.sol\";\nimport \"@chainlink/contracts/src/v0.8/interfaces/AggregatorV3Interface.sol\";\n\n/**\n * @title Chainlink Price Feed Aggregator V3 Mock\n *\n * @notice Supports the Land Sale Price Oracle with the ILV/ETH price feed\n *\n * @dev Enables testing of the feed, playing with current timestamp\n *\n * @author Basil Gorin\n */\ncontract ChainlinkAggregatorV3Mock is AggregatorV3Interface {\n\t// values returned by `latestRoundData()`\n\tuint80 public roundIdMocked = 1;\n\tint256 public answerMocked = -1;\n\tuint256 public startedAtMocked = type(uint256).max;\n\tuint256 public updatedAtMocked = type(uint256).max;\n\tuint80 public answeredInRoundMocked = 1;\n\t// answer (conversion rate) is derived from the ILV/ETH ratio\n\t// initial conversion rate is 1 ETH = 4 ILV\n\tuint256 public ethOut = 1;\n\tuint256 public ilvIn = 4;\n\n\t/// @dev overridden value to use as now32()\n\tuint256 private _now256;\n\n\t/// @dev overrides now256()\n\tfunction setNow256(uint256 value) public {\n\t\t_now256 = value;\n\t}\n\n\t/**\n\t * @dev Testing time-dependent functionality may be difficult;\n\t *      we override time in the helper test smart contract (mock)\n\t *\n\t * @return `block.timestamp` in mainnet, custom values in testnets (if overridden)\n\t */\n\tfunction now256() public view returns (uint256) {\n\t\treturn _now256 > 0? _now256: block.timestamp;\n\t}\n\n\t/**\n\t * @dev Overrides roundId, answer, startedAt, updatedAt, answeredInRound\n\t */\n\tfunction setMockedValues(\n\t\tuint80 roundId,\n\t\tint256 answer,\n\t\tuint256 startedAt,\n\t\tuint256 updatedAt,\n\t\tuint80 answeredInRound\n\t) public {\n\t\troundIdMocked = roundId;\n\t\tanswerMocked = answer;\n\t\tstartedAtMocked = startedAt;\n\t\tupdatedAtMocked = updatedAt;\n\t\tansweredInRoundMocked = answeredInRound;\n\t}\n\n\t// updates the conversion rate\n\tfunction setRate(uint256 _ethOut, uint256 _ilvIn) public {\n\t\tethOut = _ethOut;\n\t\tilvIn = _ilvIn;\n\t}\n\n\t/**\n\t * @inheritdoc AggregatorV3Interface\n\t */\n\tfunction decimals() public pure override returns (uint8) {\n\t\treturn 18;\n\t}\n\n\t/**\n\t * @inheritdoc AggregatorV3Interface\n\t */\n\tfunction description() public pure override returns (string memory) {\n\t\treturn \"ILV / ETH (Mock!)\";\n\t}\n\n\t/**\n\t * @inheritdoc AggregatorV3Interface\n\t */\n\tfunction version() public pure override returns (uint256) {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * @inheritdoc AggregatorV3Interface\n\t */\n\tfunction getRoundData(uint80 _roundId) public view override returns (\n\t\tuint80 roundId,\n\t\tint256 answer,\n\t\tuint256 startedAt,\n\t\tuint256 updatedAt,\n\t\tuint80 answeredInRound\n\t) {\n\t\trequire(_roundId == roundIdMocked, \"roundId differs from the roundId mocked value\");\n\t\treturn latestRoundData();\n\t}\n\n\t/**\n\t * @inheritdoc AggregatorV3Interface\n\t */\n\tfunction latestRoundData() public view override returns (\n\t\tuint80 roundId,\n\t\tint256 answer,\n\t\tuint256 startedAt,\n\t\tuint256 updatedAt,\n\t\tuint80 answeredInRound\n\t) {\n\t\treturn (\n\t\t\troundIdMocked,\n\t\t\tanswerMocked >= 0? answerMocked: int256(10 ** decimals() * ethOut / ilvIn),\n\t\t\tstartedAtMocked < type(uint256).max? startedAtMocked: now256(),\n\t\t\tupdatedAtMocked < type(uint256).max? updatedAtMocked: now256(),\n\t\t\tansweredInRoundMocked\n\t\t);\n\t}\n\n}\n"
    },
    "contracts/mocks/ERC721ReceiverMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../interfaces/ERC721Spec.sol\";\n\n/**\n * @title ERC721 Receiver Mock\n *\n * @notice Zeppelin-based ERC721 Receiver Mock simulates an ERC721 receiver interface,\n *      used for testing purposes - to send ERC721 safely;\n *\n * @author Basil Gorin\n */\ncontract ERC721ReceiverMock is ERC721TokenReceiver {\n\tenum Error {\n\t\tNone,\n\t\tRevertWithMessage,\n\t\tRevertWithoutMessage,\n\t\tPanic\n\t}\n\n\tbytes4 private immutable _retval;\n\tError private immutable _error;\n\n\tevent Received(address operator, address from, uint256 tokenId, bytes data, uint256 gas);\n\n\tconstructor(bytes4 retval, Error error) {\n\t\t_retval = retval;\n\t\t_error = error;\n\t}\n\n\tfunction onERC721Received(\n\t\taddress operator,\n\t\taddress from,\n\t\tuint256 tokenId,\n\t\tbytes memory data\n\t) public override returns (bytes4) {\n\t\tif (_error == Error.RevertWithMessage) {\n\t\t\trevert(\"ERC721ReceiverMock: reverting\");\n\t\t} else if (_error == Error.RevertWithoutMessage) {\n\t\t\trevert();\n\t\t} else if (_error == Error.Panic) {\n\t\t\tuint256 a = uint256(0) / uint256(0);\n\t\t\ta;\n\t\t}\n\t\temit Received(operator, from, tokenId, data, gasleft());\n\t\treturn _retval;\n\t}\n}\n"
    },
    "contracts/mocks/LandSaleMock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../protocol/LandSale.sol\";\n\n/**\n * @title Land Sale Mock\n *\n * @dev Allows to override now32() function and test time-dependent logic\n * @dev Allows to override isActive() and test how it affects the sale\n *\n * @author Basil Gorin\n */\ncontract LandSaleMock is LandSale {\n\t/// @dev overridden value to use as now32()\n\tuint32 private _now32;\n\n\t/// @dev Defines if isActive() should be overridden\n\tbool private _activeStateOverride;\n\n\t/// @dev Overrides isActive() if `_activeStateOverride` is true\n\tbool private _activeStateValue;\n\n\t/// @dev overrides now32()\n\tfunction setNow32(uint32 value) public {\n\t\t_now32 = value;\n\t}\n\n\t/// @inheritdoc LandSale\n\tfunction now32() public view override returns (uint32) {\n\t\treturn _now32 > 0? _now32: super.now32();\n\t}\n\n\t/// @inheritdoc LandSale\n\tfunction isActive() public view override returns (bool) {\n\t\t// override state if required, delegate to super otherwise\n\t\treturn _activeStateOverride ? _activeStateValue : super.isActive();\n\t}\n\n\t/// @dev Sets isActive() override\n\tfunction setStateOverride(bool _value) public {\n\t\t_activeStateOverride = true;\n\t\t_activeStateValue = _value;\n\t}\n\n\t/// @dev Removes isActive() override\n\tfunction removeStateOverride() public {\n\t\t_activeStateOverride = false;\n\t}\n\n}\n\n/**\n * @title Land Sale Delegate Mock\n *\n * @dev Allows to buy items on the Land Sale from not EOA\n *\n * @author Basil Gorin\n */\ncontract LandSaleDelegateMock {\n\t/// @dev Sale contract to execute buy functions on\n\tLandSale private sale;\n\n\t/// @dev Creates a proxy bound to the sale contract\n\tconstructor(LandSale _sale) {\n\t\tsale = _sale;\n\t}\n\n\t/// @dev Proxies buyL2 tx execution to the Land Sale contract\n\tfunction buyL2Delegate(LandSale.PlotData memory plotData, bytes32[] memory proof) public payable {\n\t\tERC20(sale.sIlvContract()).approve(address(sale), type(uint256).max);\n\t\tsale.buyL2(plotData, proof);\n\t}\n}\n"
    },
    "contracts/mocks/ERC20Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/ERC20Impl.sol\";\n\n/**\n * @title ERC20 Mock\n *\n * @notice Zeppelin-based ERC20 Mock simulates an ERC20 token, used for testing purposes;\n *      it still has restricted access to the mint() function\n *\n * @author Basil Gorin\n */\ncontract ERC20Mock is IdentifiableToken, ERC20Impl {\n\t/**\n\t * @inheritdoc IdentifiableToken\n\t */\n\tuint256 public override TOKEN_UID = 0x9246211c0c1c75405f68424667596bc7067a6af2d90b20a6a844de948a22de33;\n\n\t/// @dev Defines if balanceOf() return value should be overridden\n\tbool private _balanceOfOverride;\n\n\t/// @dev Overrides balanceOf() return value if `_balanceOfOverride` is true\n\tuint256 private _balanceOfValue;\n\n\t/// @dev Defines if transfer() and transferFrom() return value should be overridden\n\tbool private _transferSuccessOverride;\n\n\t/// @dev Overrides transfer() and transferFrom() return value if `_transferSuccessOverride` is true\n\tbool private _transferSuccessValue;\n\n\t/// @dev Defines if transferFrom() return value should be overridden\n\tbool private _transferFromSuccessOverride;\n\n\t/// @dev Overrides transferFrom() return value if `_transferSuccessOverride` is true\n\tbool private _transferFromSuccessValue;\n\n\t/**\n\t * @dev Creates/deploys an ERC20 Mock instance\n\t *\n\t * @param _name token name (ERC20Metadata)\n\t * @param _symbol toke symbol (ERC20Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) ERC20Impl(_name, _symbol) {}\n\n\t// allows to modify TOKEN_UID\n\tfunction setUid(uint256 _uid) public {\n\t\tTOKEN_UID = _uid;\n\t}\n\n\t/// @dev Sets balanceOf() override\n\tfunction setBalanceOfOverride(uint256 _value) public {\n\t\t_balanceOfOverride = true;\n\t\t_balanceOfValue = _value;\n\t}\n\n\t/// @dev Removes balanceOf() override\n\tfunction removeBalanceOfOverride() public {\n\t\t_balanceOfOverride = false;\n\t}\n\n\t/// @dev Sets transfer() and transferFrom() override\n\tfunction setTransferSuccessOverride(bool _value) public {\n\t\t_transferSuccessOverride = true;\n\t\t_transferSuccessValue = _value;\n\t}\n\n\t/// @dev Removes transfer() and transferFrom() override\n\tfunction removeTransferSuccessOverride() public {\n\t\t_transferSuccessOverride = false;\n\t}\n\n\t/// @dev Sets transferFrom() override\n\tfunction setTransferFromSuccessOverride(bool _value) public {\n\t\t_transferFromSuccessOverride = true;\n\t\t_transferFromSuccessValue = _value;\n\t}\n\n\t/// @dev Removes transferFrom() override\n\tfunction removeTransferFromSuccessOverride() public {\n\t\t_transferFromSuccessOverride = false;\n\t}\n\n\t/// @inheritdoc ERC20\n\tfunction balanceOf(address account) public view override returns(uint256) {\n\t\treturn _balanceOfOverride? _balanceOfValue: super.balanceOf(account);\n\t}\n\n\t/// @inheritdoc ERC20\n\tfunction transfer(address recipient, uint256 amount) public override returns (bool) {\n\t\tbool retVal = super.transfer(recipient, amount);\n\t\treturn _transferSuccessOverride? _transferSuccessValue: retVal;\n\t}\n\n\t/// @inheritdoc ERC20\n\tfunction transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\n\t\tbool retVal = super.transferFrom(sender, recipient, amount);\n\t\tif(_transferFromSuccessOverride) {\n\t\t\treturn _transferFromSuccessValue;\n\t\t}\n\t\tif(_transferSuccessOverride) {\n\t\t\treturn _transferSuccessValue;\n\t\t}\n\t\treturn retVal;\n\t}\n\n\tfunction transferInternal(\n\t\taddress from,\n\t\taddress to,\n\t\tuint256 value\n\t) public {\n\t\t_transfer(from, to, value);\n\t}\n\n\tfunction approveInternal(\n\t\taddress owner,\n\t\taddress spender,\n\t\tuint256 value\n\t) public {\n\t\t_approve(owner, spender, value);\n\t}\n}\n"
    },
    "contracts/mocks/ERC721Mock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.4;\n\nimport \"../token/ERC721Impl.sol\";\n\n/**\n * @title ERC721 Mock\n *\n * @notice Zeppelin-based ERC721 Mock simulates an NFT token, used for testing purposes;\n *      it still has restricted access to the mint() function\n *\n * @author Basil Gorin\n */\ncontract ERC721Mock is ERC721Impl {\n\t/**\n\t * @inheritdoc IdentifiableToken\n\t */\n\tuint256 public override TOKEN_UID = 0x805d1eb685f9eaad4306ed05ef803361e9c0b3aef93774c4b118255ab3f9c7d1;\n\n\t/**\n\t * @dev Creates/deploys an NFT Mock instance\n\t *\n\t * @param _name token name (ERC721Metadata)\n\t * @param _symbol token symbol (ERC721Metadata)\n\t */\n\tconstructor(string memory _name, string memory _symbol) ERC721Impl(_name, _symbol) {}\n\n\t// allows to modify TOKEN_UID\n\tfunction setUid(uint256 _uid) public {\n\t\tTOKEN_UID = _uid;\n\t}\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}